{
    "docs": [
        {
            "location": "/",
            "text": "Daptin is an \nopen-source backend\n to develop and deploy \nproduction-ready APIs\n based applications. With Daptin you can design your data model and have a production ready JSON API online in minutes.\n\n\nBy following shared conventions, you can increase productivity, take advantage of generalized tooling, and focus on what matters: your application.\n\n\nEasily consume the following features on any device\n\n\n\n\nRelational database backed persistent data\n\n\nCRUD \nJSON API\n\n\nUser registration and login system\n\n\nSocial login with oauth2: tested with google, github, linkedin\n\n\nExtensive state tracking APIs\n\n\nEnable \nData Auditing\n from a single switch\n\n\nMarket place\n enabling a variety of features\n\n\nCloud storage sync\n like gdrive, dropbox, b2, s3 and more\n\n\nManage multiple websites under separate sub-domain/sub-paths\n\n\n\n\nConnect with external APIs by using internal extension points\n\n\n\n\n\n\nDatabase\n to easily evolves your data schema & migrates your database [Postgres/MySQL/SQLite]\n\n\n\n\nFlexible auth\n using the JWT-based authentication & permission system\n\n\nWorks with all frontend frameworks\n like React, Vue.js, Angular, Android, iOS\n\n\nVery low memory requirement\n and horizontally scalable\n\n\nCan be deployed on a wide range of hardware\n arm5,arm6,arm7,arm64,mips,mips64,mips64le,mipsle (or build for your target using go)\n\n\n\n\nGuides\nLink\n\n\n\n\nCreate a site using a google drive folder\n\n\nCreating a todo list backend\n\n\n\n\nDocumentation\nLink\n\n\nInstallation\nLink\n\n\n\n\nRead me first\n\n\nNative\n\n\nHeroku\n\n\nDocker\n\n\nDocker Compose\n\n\nKubernetes\n\n\nChoose your storage\n\n\n\n\nSetup and data\nLink\n\n\n\n\nDesigning data model\n\n\nLinking data with one another\n\n\nDatabase configuration\n\n\nImport data\n\n\n\n\nAPIs\nLink\n\n\n\n\nCRUD APIs\n\n\nRead, search, filter\n\n\nCreate\n\n\nUpdate\n\n\nDelete\n\n\nRelations\n\n\nExecute\n\n\nAction APIs\n\n\nUsing actions\n\n\nActions list\n\n\nUser APIs\n\n\nUser registration/signup\n\n\nUser login/signin\n\n\nState tracking APIs\n\n\nState machines\n\n\n\n\nUsers\nLink\n\n\n\n\nGuests\n\n\nAdding users\n\n\nUsergroups\n\n\nData access permission\n\n\nSocial login\n\n\n\n\nAuth & Auth\nLink\n\n\n\n\nUser Authentication\n\n\nAuthorization\n\n\n\n\nAsset and file storage\nLink\n\n\n\n\nCloud storage\n\n\n\n\nSub-sites\nLink\n\n\n\n\nCreating a subsite\n\n\n\n\nWhere to begin\nLink\n\n\nThe first thing you want to do after deploying a new instance is register yourself as a user on the dashboard. This part can be automated for redistributable applications.\n\n\nBecome admin\nLink\n\n\nOnly the first user can become an \nadministrator\n and only until no one else signs up. If the first user doesn't invoke \"Become admin\" before another user signs up, then it becomes a public instance which is something you would rarely want.\n\n\nWhen you \"Become admin\", daptin will restart itself and schedule an update for itself where it makes you \nthe owner\n of everything and update permission of all exposed apis. At this point guest users will not be allowed to invoke sign up process.\n\n\nUsage Road map\nLink\n\n\nQuick road map to various things you can do from here:\n\n\n\n\nEnable sign up for guests\n\n\nExpose APIs\n\n\nSet access permission\n\n\nGet a client library\n for your frontend\n\n\nEnable Auditing\n to maintain change logs\n\n\nConnect to a cloud storage\n\n\nHost a \nstatic-site\n\n\n\n\nImport data\nLink\n\n\n\n\nXLS\n\n\nCSV\n\n\nJSON\n\n\nSchema",
            "title": "Introduction"
        },
        {
            "location": "/#guides",
            "text": "Create a site using a google drive folder  Creating a todo list backend",
            "title": "Guides"
        },
        {
            "location": "/#documentation",
            "text": "",
            "title": "Documentation"
        },
        {
            "location": "/#installation",
            "text": "Read me first  Native  Heroku  Docker  Docker Compose  Kubernetes  Choose your storage",
            "title": "Installation"
        },
        {
            "location": "/#setup-and-data",
            "text": "Designing data model  Linking data with one another  Database configuration  Import data",
            "title": "Setup and data"
        },
        {
            "location": "/#apis",
            "text": "CRUD APIs  Read, search, filter  Create  Update  Delete  Relations  Execute  Action APIs  Using actions  Actions list  User APIs  User registration/signup  User login/signin  State tracking APIs  State machines",
            "title": "APIs"
        },
        {
            "location": "/#users",
            "text": "Guests  Adding users  Usergroups  Data access permission  Social login",
            "title": "Users"
        },
        {
            "location": "/#auth-auth",
            "text": "User Authentication  Authorization",
            "title": "Auth &amp; Auth"
        },
        {
            "location": "/#asset-and-file-storage",
            "text": "Cloud storage",
            "title": "Asset and file storage"
        },
        {
            "location": "/#sub-sites",
            "text": "Creating a subsite",
            "title": "Sub-sites"
        },
        {
            "location": "/#where-to-begin",
            "text": "The first thing you want to do after deploying a new instance is register yourself as a user on the dashboard. This part can be automated for redistributable applications.",
            "title": "Where to begin"
        },
        {
            "location": "/#become-admin",
            "text": "Only the first user can become an  administrator  and only until no one else signs up. If the first user doesn't invoke \"Become admin\" before another user signs up, then it becomes a public instance which is something you would rarely want.  When you \"Become admin\", daptin will restart itself and schedule an update for itself where it makes you  the owner  of everything and update permission of all exposed apis. At this point guest users will not be allowed to invoke sign up process.",
            "title": "Become admin"
        },
        {
            "location": "/#usage-road-map",
            "text": "Quick road map to various things you can do from here:   Enable sign up for guests  Expose APIs  Set access permission  Get a client library  for your frontend  Enable Auditing  to maintain change logs  Connect to a cloud storage  Host a  static-site",
            "title": "Usage Road map"
        },
        {
            "location": "/#import-data",
            "text": "XLS  CSV  JSON  Schema",
            "title": "Import data"
        },
        {
            "location": "/setting-up/native/",
            "text": "Native binary\nLink\n\n\nDaptin is available as a native binary. You can download the binary for the following os from \ngithub releases\n\n\n\n\nWindows 32/64\n\n\nOS X  64\n\n\nLinux  32/64/arm/mips\n\n\n\n\nhttps://github.com/daptin/daptin/releases\n\n\nExecute \n./daptin\n to run daptin.\n\n\nIt will create a sqlite database on the disk and start listening on port 6336.\n\n\nArguments:\n\n\n\n\n-port: set the port to listen\n\n\n-db_type: mysql/postgres/sqlite3\n\n\n-db_connection_string:\n\n\nSQLite: \ntest.db\n\n\nMySql: \n<username>:<password>@tcp(<hostname>:<port>)/<db_name>\n\n\nPostgres: \nhost=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable",
            "title": "Native"
        },
        {
            "location": "/setting-up/native/#native-binary",
            "text": "Daptin is available as a native binary. You can download the binary for the following os from  github releases   Windows 32/64  OS X  64  Linux  32/64/arm/mips   https://github.com/daptin/daptin/releases  Execute  ./daptin  to run daptin.  It will create a sqlite database on the disk and start listening on port 6336.  Arguments:   -port: set the port to listen  -db_type: mysql/postgres/sqlite3  -db_connection_string:  SQLite:  test.db  MySql:  <username>:<password>@tcp(<hostname>:<port>)/<db_name>  Postgres:  host=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable",
            "title": "Native binary"
        },
        {
            "location": "/setting-up/heroku/",
            "text": "Heroku deployment\nLink\n\n\nHeroku is the best way to test out a live instance of daptin. Daptin has a very low memory footprint and can run smoothly even on heroku's smallest instance.\n\n\n\n\nNote: Heroku puts instances to sleep after 30 minutes of idleness, which will erase all the data. It will behave like a fresh instance when it wakes up. You can subscribe to their minimum paid plan to remove this sleep due to idleness.",
            "title": "Heroku"
        },
        {
            "location": "/setting-up/heroku/#heroku-deployment",
            "text": "Heroku is the best way to test out a live instance of daptin. Daptin has a very low memory footprint and can run smoothly even on heroku's smallest instance.   Note: Heroku puts instances to sleep after 30 minutes of idleness, which will erase all the data. It will behave like a fresh instance when it wakes up. You can subscribe to their minimum paid plan to remove this sleep due to idleness.",
            "title": "Heroku deployment"
        },
        {
            "location": "/setting-up/docker/",
            "text": "Docker image\nLink\n\n\nDeploy the docker image\n\n\nStart \ndaptin\n on your machine using docker\n\n\ndocker run -p 8080:8080 daptin/daptin\n\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n\n\n\nhttps://hub.docker.com/r/daptin/daptin/",
            "title": "Docker"
        },
        {
            "location": "/setting-up/docker/#docker-image",
            "text": "Deploy the docker image  Start  daptin  on your machine using docker  docker run -p 8080:8080 daptin/daptin  \n     \n     \n     \n     \n     \n       https://hub.docker.com/r/daptin/daptin/",
            "title": "Docker image"
        },
        {
            "location": "/setting-up/docker-compose/",
            "text": "Docker compose\nLink\n\n\nDocker compose is a great tool to bring up a mysql/postgres backed daptin instance\n\n\nversion\n:\n \n'3'\n\n\nservices\n:\n\n    \nweb\n:\n\n        \nimage\n:\n \ndaptin/daptin\n\n        \nports\n:\n\n            \n-\n \n\"8090:8080\"\n\n        \nrestart\n:\n \nalways\n\n        \nenvironment\n:\n\n          \nDAPTIN_PORT\n:\n \n'8080'\n\n          \nDAPTIN_DB_TYPE\n:\n \n'mysql'\n\n          \nDAPTIN_DB_CONNECTION_STRING\n:\n \n'dev:dev@tcp(mysqldb:3306)/daptin'\n\n        \ndepends_on\n:\n\n            \n-\n \nmysqldb\n\n    \nmysqldb\n:\n\n        \nimage\n:\n \nmysql\n\n        \ncontainer_name\n:\n \n${MYSQL_HOST}\n\n        \nrestart\n:\n \nalways\n\n        \nenv_file\n:\n\n            \n-\n \n\".env\"\n\n        \nenvironment\n:\n\n            \n-\n \nMYSQL_DATABASE=${MYSQL_DATABASE}\n\n            \n-\n \nMYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n\n            \n-\n \nMYSQL_USER=${MYSQL_USER}\n\n            \n-\n \nMYSQL_PASSWORD=${MYSQL_PASSWORD}\n\n        \nports\n:\n\n            \n-\n \n\"8989:3306\"\n\n        \nvolumes\n:\n\n            \n-\n \n\"./data/db/mysql:/var/lib/mysql\"",
            "title": "Docker Compose"
        },
        {
            "location": "/setting-up/docker-compose/#docker-compose",
            "text": "Docker compose is a great tool to bring up a mysql/postgres backed daptin instance  version :   '3'  services : \n     web : \n         image :   daptin/daptin \n         ports : \n             -   \"8090:8080\" \n         restart :   always \n         environment : \n           DAPTIN_PORT :   '8080' \n           DAPTIN_DB_TYPE :   'mysql' \n           DAPTIN_DB_CONNECTION_STRING :   'dev:dev@tcp(mysqldb:3306)/daptin' \n         depends_on : \n             -   mysqldb \n     mysqldb : \n         image :   mysql \n         container_name :   ${MYSQL_HOST} \n         restart :   always \n         env_file : \n             -   \".env\" \n         environment : \n             -   MYSQL_DATABASE=${MYSQL_DATABASE} \n             -   MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} \n             -   MYSQL_USER=${MYSQL_USER} \n             -   MYSQL_PASSWORD=${MYSQL_PASSWORD} \n         ports : \n             -   \"8989:3306\" \n         volumes : \n             -   \"./data/db/mysql:/var/lib/mysql\"",
            "title": "Docker compose"
        },
        {
            "location": "/setting-up/kubernetes/",
            "text": "Kubernetes deployment\nLink\n\n\nDaptin can be infinitely scaled on kubernetes\n\n\n\n\nExample\n\n\napiVersion\n:\n \nv1\n\n\nkind\n:\n \nService\n\n\nmetadata\n:\n\n  \nname\n:\n \ndaptin-instance\n\n  \nlabels\n:\n\n    \napp\n:\n \ndaptin\n\n\nspec\n:\n\n  \nports\n:\n\n    \n-\n \nport\n:\n \n8080\n\n  \nselector\n:\n\n    \napp\n:\n \ndaptin\n\n    \ntier\n:\n \nproduction\n\n\n---\n\n\napiVersion\n:\n \nextensions/v1beta1\n\n\nkind\n:\n \nDeployment\n\n\nmetadata\n:\n\n  \nname\n:\n \ndaptin-daptin\n\n  \nlabels\n:\n\n    \napp\n:\n \ndaptin\n\n\nspec\n:\n\n  \nstrategy\n:\n\n    \ntype\n:\n \nRecreate\n\n  \ntemplate\n:\n\n    \nmetadata\n:\n\n      \nlabels\n:\n\n        \napp\n:\n \ndaptin\n\n        \ntier\n:\n \ntesting\n\n    \nspec\n:\n\n      \ncontainers\n:\n\n      \n-\n \nimage\n:\n \ndaptin/daptin:latest\n\n        \nname\n:\n \ndaptin\n\n        \nargs\n:\n \n[\n'-db_type'\n,\n \n'mysql'\n,\n \n'-db_connection_string'\n,\n \n'user:password@tcp(<mysql_service>:3306)/daptin'\n]\n\n        \nports\n:\n\n        \n-\n \ncontainerPort\n:\n \n8080\n\n          \nname\n:\n \ndaptin\n\n\n---\n\n\napiVersion\n:\n \nextensions/v1beta1\n\n\nkind\n:\n \nIngress\n\n\nmetadata\n:\n\n  \nname\n:\n \ndaptin-test\n\n\nspec\n:\n\n  \nrules\n:\n\n  \n-\n \nhost\n:\n \nhello.website\n\n    \nhttp\n:\n\n      \npaths\n:\n\n      \n-\n \nbackend\n:\n\n          \nserviceName\n:\n \ndaptin-testing\n\n          \nservicePort\n:\n \n8080",
            "title": "Kubernetes"
        },
        {
            "location": "/setting-up/kubernetes/#kubernetes-deployment",
            "text": "Daptin can be infinitely scaled on kubernetes   Example  apiVersion :   v1  kind :   Service  metadata : \n   name :   daptin-instance \n   labels : \n     app :   daptin  spec : \n   ports : \n     -   port :   8080 \n   selector : \n     app :   daptin \n     tier :   production  ---  apiVersion :   extensions/v1beta1  kind :   Deployment  metadata : \n   name :   daptin-daptin \n   labels : \n     app :   daptin  spec : \n   strategy : \n     type :   Recreate \n   template : \n     metadata : \n       labels : \n         app :   daptin \n         tier :   testing \n     spec : \n       containers : \n       -   image :   daptin/daptin:latest \n         name :   daptin \n         args :   [ '-db_type' ,   'mysql' ,   '-db_connection_string' ,   'user:password@tcp(<mysql_service>:3306)/daptin' ] \n         ports : \n         -   containerPort :   8080 \n           name :   daptin  ---  apiVersion :   extensions/v1beta1  kind :   Ingress  metadata : \n   name :   daptin-test  spec : \n   rules : \n   -   host :   hello.website \n     http : \n       paths : \n       -   backend : \n           serviceName :   daptin-testing \n           servicePort :   8080",
            "title": "Kubernetes deployment"
        },
        {
            "location": "/setting-up/database_configuration/",
            "text": "Database\nLink\n\n\nDaptin can use one of the following database for data persistence\n\n\n\n\nMysql\n\n\nPostgres\n\n\nSQLite [Default]\n\n\n\n\nIf nothing specified, a \nsqlite\n database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)\n\n\nYou can customise the database connection properties when starting daptin\n\n\nmysql\nLink\n\n\nTo use mysql, start daptin as follows\n\n\n./daptin -db_type=mysql -db_connection_string='<username>:<password>@tcp(<hostname>:<port>)/<db_name>'\n\n\npostgres\nLink\n\n\n./daptin -db_type=postgres -db_connection_string='host=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable'\n\n\nsqlite\nLink\n\n\nBy default a \"daptin.db\" file is created to store data\n\n\n./daptin -db_type=sqlite -db_connection_string=db_file_name.db",
            "title": "Choose your storage"
        },
        {
            "location": "/setting-up/database_configuration/#database",
            "text": "Daptin can use one of the following database for data persistence   Mysql  Postgres  SQLite [Default]   If nothing specified, a  sqlite  database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)  You can customise the database connection properties when starting daptin",
            "title": "Database"
        },
        {
            "location": "/setting-up/database_configuration/#mysql",
            "text": "To use mysql, start daptin as follows  ./daptin -db_type=mysql -db_connection_string='<username>:<password>@tcp(<hostname>:<port>)/<db_name>'",
            "title": "mysql"
        },
        {
            "location": "/setting-up/database_configuration/#postgres",
            "text": "./daptin -db_type=postgres -db_connection_string='host=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable'",
            "title": "postgres"
        },
        {
            "location": "/setting-up/database_configuration/#sqlite",
            "text": "By default a \"daptin.db\" file is created to store data  ./daptin -db_type=sqlite -db_connection_string=db_file_name.db",
            "title": "sqlite"
        },
        {
            "location": "/setting-up/settingup/",
            "text": "Setting up Daptin\nLink\n\n\nDaptin is built in golang and a static artifact is available for most targets\n\n\nDeploy and get started\nLink\n\n\n\n\n\n\n\n\nDeployment preference\n\n\nGetting started\n\n\n\n\n\n\n\n\n\n\nHeroku\n\n\n\n\n\n\n\n\nDocker\n\n\ndocker run -p 8080:8080 daptin/daptin\n\n\n\n\n\n\nKubernetes\n\n\nService & Deployment YAML\n\n\n\n\n\n\nDevelopment\n\n\ngo get github.com/daptin/daptin\n\n\n\n\n\n\nLinux (386/amd64/arm5,6,7)\n\n\nDownload static linux builds\n\n\n\n\n\n\nWindows\n\n\ngo get github.com/daptin/daptin\n\n\n\n\n\n\nOS X\n\n\ngo get github.com/daptin/daptin\n\n\n\n\n\n\nLoad testing\n\n\nDocker compose\n\n\n\n\n\n\nRaspberry Pi\n\n\nLinux arm 7 static build\n\n\n\n\n\n\n\n\nPort\nLink\n\n\nDaptin will listen on port 6336 by default. You can change it by using the following argument\n\n\n-port=8080\n\n\nRestart\nLink\n\n\nDaptin relies on self \nre-configuration\n to configure new entities and APIs and changes to the other parts of the ststem. As soon as you upload a schema file, daptin will write the file to disk, and \nreconfigure\n itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.\n\n\nYou can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.\n\n\nDetailed instructions\nLink",
            "title": "Getting started"
        },
        {
            "location": "/setting-up/settingup/#setting-up-daptin",
            "text": "Daptin is built in golang and a static artifact is available for most targets",
            "title": "Setting up Daptin"
        },
        {
            "location": "/setting-up/settingup/#deploy-and-get-started",
            "text": "Deployment preference  Getting started      Heroku     Docker  docker run -p 8080:8080 daptin/daptin    Kubernetes  Service & Deployment YAML    Development  go get github.com/daptin/daptin    Linux (386/amd64/arm5,6,7)  Download static linux builds    Windows  go get github.com/daptin/daptin    OS X  go get github.com/daptin/daptin    Load testing  Docker compose    Raspberry Pi  Linux arm 7 static build",
            "title": "Deploy and get started"
        },
        {
            "location": "/setting-up/settingup/#port",
            "text": "Daptin will listen on port 6336 by default. You can change it by using the following argument  -port=8080",
            "title": "Port"
        },
        {
            "location": "/setting-up/settingup/#restart",
            "text": "Daptin relies on self  re-configuration  to configure new entities and APIs and changes to the other parts of the ststem. As soon as you upload a schema file, daptin will write the file to disk, and  reconfigure  itself. When it starts it will read the schema file, make appropriate changes to the database and expose JSON apis for the entities and actions.  You can issue a daptin restart from the dashboard. Daptin takes about 15 seconds approx to start up and configure everything.",
            "title": "Restart"
        },
        {
            "location": "/setting-up/settingup/#detailed-instructions",
            "text": "",
            "title": "Detailed instructions"
        },
        {
            "location": "/setting-up/entities/",
            "text": "Data modeling\nLink\n\n\nTables are the basic data structure. Tables have columns. Each column has a particular data type. Tables are exposed as JSON APIs under the \n/api/\n path. Checkout \nentity documentation\n for details.\n\n\n\n\nYAML example\n\n\nTables\n:\n\n\n-\n \nTableName\n:\n \ntodo\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(500)\n\n    \nColumnType\n:\n \nlabel\n\n    \nIsIndexed\n:\n \ntrue\n\n\n\n\n\n\n\n\n\nJSON example\n\n\n{\n\n  \n\"Tables\"\n:\n \n[\n\n    \n{\n\n      \n\"TableName\"\n:\n \n\"todo\"\n,\n\n      \n\"Columns\"\n:\n \n[\n\n        \n{\n\n          \n\"Name\"\n:\n \n\"title\"\n,\n\n          \n\"DataType\"\n:\n \n\"varchar(500)\"\n,\n\n          \n\"ColumnType\"\n:\n \n\"label\"\n,\n\n          \n\"IsIndexed\"\n:\n \ntrue\n\n        \n}\n\n      \n]\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\n\n\n\nAutomatic creation\nLink\n\n\nImport CSV or XLS file and you can let Daptin create the entities for you based on intelligent data pre-processor.\n\n\nManual creation\nLink\n\n\nIf you are looking for a more reproducible way, design your entities and create JSON or YAML files. These files can be used again to create an exact same replica.\n\n\nMultiple schema json files can be uploaded, and changes are merged accordingly.\n\n\nLets imagine we were creating a todo application and wanted to keep a track of the following for each todo item\n\n\nColumn descriptions\nLink\n\n\n\n\nTodo list example\n\n\n\n\nthe todo text field - title\n\n\na description text field - may or may not be empty\n\n\na deadline date field - a date field to capture the deadline\n\n\ncompleted - a true/false field, which captures if the todo is done\n\n\norder - a field to store the priority of each todo\n\n\n\n\n\n\nData validations\nLink\n\n\nAlong with the fields mentioned above, we might want certain validations and conformations whenever we store a new todo\n\n\n\n\nValidations\n\n\n\n\ntitle cannot be empty\n\n\norder has to be numeric\n\n\n\n\n\n\nOnce we have come up with the above picture in mind, we can use one of the following ways to tell daptin about this.\n\n\nJSON example\nLink\n\n\nJSON files are the primary way to create new entities in daptin. The above two ways ultimately create a JSON file or fetch from the market.\n\n\nThe JSON for our \ntodo\n entity will look as follows:\n\n\n    \n{\n\n        \n\"Tables\"\n:\n \n[{\n\n            \n\"TableName\"\n:\n \n\"todo\"\n,\n\n            \n\"Columns\"\n:\n \n[{\n\n                    \n\"Name\"\n:\n \n\"title\"\n,\n\n                    \n\"DataType\"\n:\n \n\"varchar(500)\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"label\"\n,\n\n                    \n\"IsIndexed\"\n:\n \ntrue\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"completed\"\n,\n\n                    \n\"DataType\"\n:\n \n\"int(1)\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"truefalse\"\n,\n\n                    \n\"DefaultValue\"\n:\n \n\"false\"\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"deadline\"\n,\n\n                    \n\"DataType\"\n:\n \n\"date\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"date\"\n,\n\n                    \n\"IsNullable\"\n:\n \ntrue\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"order\"\n,\n\n                    \n\"ColumnName\"\n:\n \n\"item_order\"\n,\n\n                    \n\"DataType\"\n:\n \n\"int(4)\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"measurement\"\n,\n\n                    \n\"DefaultValue\"\n:\n \n\"10\"\n\n                \n},\n\n                \n{\n\n                    \n\"Name\"\n:\n \n\"text\"\n,\n\n                    \n\"DataType\"\n:\n \n\"text\"\n,\n\n                    \n\"ColumnType\"\n:\n \n\"content\"\n,\n\n                    \n\"IsNullable\"\n:\n \ntrue\n\n                \n}\n\n            \n],\n\n            \n\"Conformations\"\n:\n \n[{\n\n                \n\"ColumnName\"\n:\n \n\"order\"\n,\n\n                \n\"Tags\"\n:\n \n\"numeric\"\n\n            \n}],\n\n            \n\"validations\"\n:\n \n[{\n\n                \n\"ColumnName\"\n:\n \n\"title\"\n,\n\n                \n\"Tags\"\n:\n \n\"required\"\n\n            \n}]\n\n\n]\n}\n\n\n\n\n\n\n\nName: Name is a human readable name\n\n\nColumn Name: Name of the column in the table\n\n\nColumn Type: The type of the column. Daptin supports a variety of types and these allow daptin to give you useful options in future (eg for viewing a timeline, a date/datetime column is required)\n\n\nDefault value: Columns can have default values, which is used a new row is created and no value for that column is specified.\n\n\n\n\nYAML example\nLink\n\n\nYAML example for \ntodo\n entity is as follows\n\n\nTables\n:\n\n\n-\n \nTableName\n:\n \ntodo\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(500)\n\n    \nColumnType\n:\n \nlabel\n\n    \nIsIndexed\n:\n \ntrue\n\n  \n-\n \nName\n:\n \nurl\n\n    \nDataType\n:\n \nvarchar(200)\n\n    \nColumnType\n:\n \nurl\n\n    \nIsNullable\n:\n \ntrue\n\n  \n-\n \nName\n:\n \ncompleted\n\n    \nDataType\n:\n \nint(1)\n\n    \nColumnType\n:\n \ntruefalse\n\n    \nDefaultValue\n:\n \n'false'\n\n  \n-\n \nName\n:\n \nschedule\n\n    \nDataType\n:\n \ndate\n\n    \nColumnType\n:\n \ndate\n\n    \nIsNullable\n:\n \ntrue\n\n  \n-\n \nName\n:\n \norder\n\n    \nColumnName\n:\n \nitem_order\n\n    \nDataType\n:\n \nint(4)\n\n    \nColumnType\n:\n \nmeasurement\n\n    \nDefaultValue\n:\n \n'10'\n\n  \n-\n \nName\n:\n \ntext\n\n    \nDataType\n:\n \ntext\n\n    \nColumnType\n:\n \ncontent\n\n    \nIsNullable\n:\n \ntrue\n\n  \nConformations\n:\n\n  \n-\n \nColumnName\n:\n \norder\n\n    \nTags\n:\n \nnumeric\n\n  \nValidations\n:\n\n  \n-\n \nColumnName\n:\n \ntitle\n\n\nTags\n:\n \nrequired\n\n\n\n\n\nYou can choose to work with either json or yaml. Once the schema is ready, it can be uploaded directly from daptin dashboard.\n\n\nOnline entity designer\nLink\n\n\nThe entity designer is accessible from dashboard using the \"Online designer\" button. Here you can set the name, add columns and relations and create it. This is a basic designer and more advanced features to customise every aspect of the entity will be added later.\n\n\n\n\nMarket place\nLink\n\n\nCheckout \nmarketplace documentation\n\n\nColumn specifications\nLink\n\n\nColumns of the entity can be customized:\n\n\n\n\n\n\n\n\nProperty Name\n\n\nProperty Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nName\n\n\nstring\n\n\nhuman readable name, can be skipped\n\n\n\n\n\n\nColumnName\n\n\nstring\n\n\ncolumn name in the table\n\n\n\n\n\n\nColumnDescription\n\n\nstring\n\n\nhuman readable description\n\n\n\n\n\n\nColumnType\n\n\nstring\n\n\ncolumn type is a rich type of the column\n\n\n\n\n\n\nIsIndexed\n\n\nboolean\n\n\ntrue to add an index on this column\n\n\n\n\n\n\nIsUnique\n\n\nboolean\n\n\ntrue to set a unique constraint on this column\n\n\n\n\n\n\nIsNullable\n\n\nboolean\n\n\nare null values allowed\n\n\n\n\n\n\nPermission\n\n\nuint64\n\n\npermission column (check authorization docs)\n\n\n\n\n\n\nDataType\n\n\nstring\n\n\nthe column type inside the database\n\n\n\n\n\n\nDefaultValue\n\n\nstring\n\n\ndefault value if any (has to be inside single quotes for static values\n\n\n\n\n\n\n\n\nColumn types\nLink\n\n\nDaptin supports a variety of rich data types, which helps it to automatically make intelligent decisions and validations. Here is a list of all column types and what should they be used for\n\n\n\n\n\n\n\n\nType Name\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nid\n\n\nan identity column, mostly for internal purposes\n\n\n1\n\n\n\n\n\n\nalias\n\n\na foreign key column\n\n\nuuid v4\n\n\n\n\n\n\ndate\n\n\nfull date, no time\n\n\n2017-12-30\n\n\n\n\n\n\ntime\n\n\ntime/time interval, no date\n\n\n12:34:54\n\n\n\n\n\n\nday\n\n\nday of the month\n\n\n1 to 31\n\n\n\n\n\n\nmonth\n\n\nmonth of the year\n\n\n1 to 12\n\n\n\n\n\n\nyear\n\n\nYear\n\n\n2017\n\n\n\n\n\n\nminute\n\n\nminute of the hour\n\n\n0 to 59\n\n\n\n\n\n\nhour\n\n\nhour of the dat\n\n\n0 - 23\n\n\n\n\n\n\ndatetime\n\n\ndate + time (not stored as timestamp, served at date time string)\n\n\n2017-12-30T12:34:54\n\n\n\n\n\n\nemail\n\n\nemail\n\n\ntest@domain.com\n\n\n\n\n\n\nname\n\n\ncolumn to be used as name of the entity\n\n\ndaptin\n\n\n\n\n\n\njson\n\n\nJSON data\n\n\n{}\n\n\n\n\n\n\npassword\n\n\npassword - are bcrypted with cost 11\n\n\n$2a$11$z/VlxycDgZ...\n\n\n\n\n\n\nvalue\n\n\nvalue is enumeration type\n\n\ncompleted\n\n\n\n\n\n\ntruefalse\n\n\nboolean\n\n\n1\n\n\n\n\n\n\ntimestamp\n\n\ntimestamp (stored as timestamp, served as timestamp)\n\n\n123123123\n\n\n\n\n\n\nlocation.latitude\n\n\nonly latitude\n\n\n34.2938\n\n\n\n\n\n\nlocation\n\n\nlatitude + longitude in geoJson format\n\n\n[34.223,64.123]\n\n\n\n\n\n\nlocation.longitude\n\n\nonly longitude\n\n\n64.123\n\n\n\n\n\n\nlocation.altitude\n\n\nonly altitude\n\n\n34\n\n\n\n\n\n\ncolor\n\n\nhex color string\n\n\n#ABCDE1\n\n\n\n\n\n\nrating.10\n\n\nrating on a scale of 10\n\n\n8\n\n\n\n\n\n\nmeasurement\n\n\nnumeric column\n\n\n534\n\n\n\n\n\n\nlabel\n\n\na label for the entity, similar to name but can be more than one\n\n\nred\n\n\n\n\n\n\ncontent\n\n\nlarger contents - texts/html/json/yaml\n\n\nvery long text\n\n\n\n\n\n\nfile\n\n\nuploads, connect storage for using this\n\n\n\n\n\n\n\n\nurl\n\n\nUrls/links\n\n\nhttp://docs.dapt.in",
            "title": "Designing data model"
        },
        {
            "location": "/setting-up/entities/#data-modeling",
            "text": "Tables are the basic data structure. Tables have columns. Each column has a particular data type. Tables are exposed as JSON APIs under the  /api/  path. Checkout  entity documentation  for details.   YAML example  Tables :  -   TableName :   todo \n   Columns : \n   -   Name :   title \n     DataType :   varchar(500) \n     ColumnType :   label \n     IsIndexed :   true     JSON example  { \n   \"Tables\" :   [ \n     { \n       \"TableName\" :   \"todo\" , \n       \"Columns\" :   [ \n         { \n           \"Name\" :   \"title\" , \n           \"DataType\" :   \"varchar(500)\" , \n           \"ColumnType\" :   \"label\" , \n           \"IsIndexed\" :   true \n         } \n       ] \n     } \n   ]  }",
            "title": "Data modeling"
        },
        {
            "location": "/setting-up/entities/#automatic-creation",
            "text": "Import CSV or XLS file and you can let Daptin create the entities for you based on intelligent data pre-processor.",
            "title": "Automatic creation"
        },
        {
            "location": "/setting-up/entities/#manual-creation",
            "text": "If you are looking for a more reproducible way, design your entities and create JSON or YAML files. These files can be used again to create an exact same replica.  Multiple schema json files can be uploaded, and changes are merged accordingly.  Lets imagine we were creating a todo application and wanted to keep a track of the following for each todo item",
            "title": "Manual creation"
        },
        {
            "location": "/setting-up/entities/#column-descriptions",
            "text": "Todo list example   the todo text field - title  a description text field - may or may not be empty  a deadline date field - a date field to capture the deadline  completed - a true/false field, which captures if the todo is done  order - a field to store the priority of each todo",
            "title": "Column descriptions"
        },
        {
            "location": "/setting-up/entities/#data-validations",
            "text": "Along with the fields mentioned above, we might want certain validations and conformations whenever we store a new todo   Validations   title cannot be empty  order has to be numeric    Once we have come up with the above picture in mind, we can use one of the following ways to tell daptin about this.",
            "title": "Data validations"
        },
        {
            "location": "/setting-up/entities/#json-example",
            "text": "JSON files are the primary way to create new entities in daptin. The above two ways ultimately create a JSON file or fetch from the market.  The JSON for our  todo  entity will look as follows:       { \n         \"Tables\" :   [{ \n             \"TableName\" :   \"todo\" , \n             \"Columns\" :   [{ \n                     \"Name\" :   \"title\" , \n                     \"DataType\" :   \"varchar(500)\" , \n                     \"ColumnType\" :   \"label\" , \n                     \"IsIndexed\" :   true \n                 }, \n                 { \n                     \"Name\" :   \"completed\" , \n                     \"DataType\" :   \"int(1)\" , \n                     \"ColumnType\" :   \"truefalse\" , \n                     \"DefaultValue\" :   \"false\" \n                 }, \n                 { \n                     \"Name\" :   \"deadline\" , \n                     \"DataType\" :   \"date\" , \n                     \"ColumnType\" :   \"date\" , \n                     \"IsNullable\" :   true \n                 }, \n                 { \n                     \"Name\" :   \"order\" , \n                     \"ColumnName\" :   \"item_order\" , \n                     \"DataType\" :   \"int(4)\" , \n                     \"ColumnType\" :   \"measurement\" , \n                     \"DefaultValue\" :   \"10\" \n                 }, \n                 { \n                     \"Name\" :   \"text\" , \n                     \"DataType\" :   \"text\" , \n                     \"ColumnType\" :   \"content\" , \n                     \"IsNullable\" :   true \n                 } \n             ], \n             \"Conformations\" :   [{ \n                 \"ColumnName\" :   \"order\" , \n                 \"Tags\" :   \"numeric\" \n             }], \n             \"validations\" :   [{ \n                 \"ColumnName\" :   \"title\" , \n                 \"Tags\" :   \"required\" \n             }]  ] }    Name: Name is a human readable name  Column Name: Name of the column in the table  Column Type: The type of the column. Daptin supports a variety of types and these allow daptin to give you useful options in future (eg for viewing a timeline, a date/datetime column is required)  Default value: Columns can have default values, which is used a new row is created and no value for that column is specified.",
            "title": "JSON example"
        },
        {
            "location": "/setting-up/entities/#yaml-example",
            "text": "YAML example for  todo  entity is as follows  Tables :  -   TableName :   todo \n   Columns : \n   -   Name :   title \n     DataType :   varchar(500) \n     ColumnType :   label \n     IsIndexed :   true \n   -   Name :   url \n     DataType :   varchar(200) \n     ColumnType :   url \n     IsNullable :   true \n   -   Name :   completed \n     DataType :   int(1) \n     ColumnType :   truefalse \n     DefaultValue :   'false' \n   -   Name :   schedule \n     DataType :   date \n     ColumnType :   date \n     IsNullable :   true \n   -   Name :   order \n     ColumnName :   item_order \n     DataType :   int(4) \n     ColumnType :   measurement \n     DefaultValue :   '10' \n   -   Name :   text \n     DataType :   text \n     ColumnType :   content \n     IsNullable :   true \n   Conformations : \n   -   ColumnName :   order \n     Tags :   numeric \n   Validations : \n   -   ColumnName :   title  Tags :   required   You can choose to work with either json or yaml. Once the schema is ready, it can be uploaded directly from daptin dashboard.",
            "title": "YAML example"
        },
        {
            "location": "/setting-up/entities/#online-entity-designer",
            "text": "The entity designer is accessible from dashboard using the \"Online designer\" button. Here you can set the name, add columns and relations and create it. This is a basic designer and more advanced features to customise every aspect of the entity will be added later.",
            "title": "Online entity designer"
        },
        {
            "location": "/setting-up/entities/#market-place",
            "text": "Checkout  marketplace documentation",
            "title": "Market place"
        },
        {
            "location": "/setting-up/entities/#column-specifications",
            "text": "Columns of the entity can be customized:     Property Name  Property Type  Description      Name  string  human readable name, can be skipped    ColumnName  string  column name in the table    ColumnDescription  string  human readable description    ColumnType  string  column type is a rich type of the column    IsIndexed  boolean  true to add an index on this column    IsUnique  boolean  true to set a unique constraint on this column    IsNullable  boolean  are null values allowed    Permission  uint64  permission column (check authorization docs)    DataType  string  the column type inside the database    DefaultValue  string  default value if any (has to be inside single quotes for static values",
            "title": "Column specifications"
        },
        {
            "location": "/setting-up/entities/#column-types",
            "text": "Daptin supports a variety of rich data types, which helps it to automatically make intelligent decisions and validations. Here is a list of all column types and what should they be used for     Type Name  Description  Example      id  an identity column, mostly for internal purposes  1    alias  a foreign key column  uuid v4    date  full date, no time  2017-12-30    time  time/time interval, no date  12:34:54    day  day of the month  1 to 31    month  month of the year  1 to 12    year  Year  2017    minute  minute of the hour  0 to 59    hour  hour of the dat  0 - 23    datetime  date + time (not stored as timestamp, served at date time string)  2017-12-30T12:34:54    email  email  test@domain.com    name  column to be used as name of the entity  daptin    json  JSON data  {}    password  password - are bcrypted with cost 11  $2a$11$z/VlxycDgZ...    value  value is enumeration type  completed    truefalse  boolean  1    timestamp  timestamp (stored as timestamp, served as timestamp)  123123123    location.latitude  only latitude  34.2938    location  latitude + longitude in geoJson format  [34.223,64.123]    location.longitude  only longitude  64.123    location.altitude  only altitude  34    color  hex color string  #ABCDE1    rating.10  rating on a scale of 10  8    measurement  numeric column  534    label  a label for the entity, similar to name but can be more than one  red    content  larger contents - texts/html/json/yaml  very long text    file  uploads, connect storage for using this     url  Urls/links  http://docs.dapt.in",
            "title": "Column types"
        },
        {
            "location": "/setting-up/entity_relations/",
            "text": "Data relations\nLink\n\n\nA data oriented system with no relational knowledge of the data is next to an Excel sheet. Specifying relations in your data is the most important thing after creating your entities.\n\n\nRelations are constraints among tables and help you keep clean and consistent data. Relational data is easily accessible over APIs using a path structure like \n/api/<entityName>/<id>/<relationName>\n and the response is consistent with \nJSONAPI.org\n.\n\n\nCheckout the \nrelation apis\n exposed by daptin.\n\n\n\n\nYAML example\n\n\nRelations\n:\n\n\n-\n \nSubject\n:\n \ntodo\n\n  \nRelation\n:\n \nhas_one\n\n  \nObject\n:\n \nproject\n\n\n\n\n\n\n\n\n\nJSON example\n\n\n{\n\n  \n\"Relations\"\n:\n \n[\n\n    \n{\n\n      \n\"Subject\"\n:\n \n\"todo\"\n,\n\n      \n\"Relation\"\n:\n \n\"has_one\"\n,\n\n      \n\"Object\"\n:\n \n\"project\"\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\n\n\n\nRelations in JSON/YAML schema\nLink\n\n\nWhen uploading schema using a JSON / YAML file, relations can be added in the same file and daptin will create appropriate constraints and foreign keys in your underlying database.\n\n\nContinuing with our example of todos, lets say we want to group todo's in \"projects\" and each todo can belong to only a single project.\n\n\nLets design a \"project\" entity:\n\n\n-\n \nTableName\n:\n \nproject\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \nname\n\n    \nDataType\n:\n \nvarchar(200)\n\n    \nColumnType\n:\n \nname\n\n    \nIsIndexed\n:\n \ntrue\n\n\n\n\n\nA very simple table with just a name column. Now we can tell daptin about the relation between todos and projects\n\n\nRelations\n:\n\n\n-\n \nSubject\n:\n \ntodo\n\n  \nRelation\n:\n \nhas_one\n\n  \nObject\n:\n \nproject\n\n\n\n\n\nThis tells daptin that todo \"has_one\" project.\n\n\nRelations types\nLink\n\n\nAny entity can be associated to any other entity (or to itself) as one of the follows\n\n\n\n\n\n\n\n\nRelation Name\n\n\nRelation Descriptio\n\n\nCan be empty\n\n\n\n\n\n\n\n\n\n\nbelongs_to\n\n\na single object relation\n\n\nNo\n\n\n\n\n\n\nhas_one\n\n\na single object relation\n\n\nYes\n\n\n\n\n\n\nhas_many\n\n\nmany related objects\n\n\nYes\n\n\n\n\n\n\n\n\nDefault relations\nLink\n\n\nEvery entity created on daptin has at least two relations\n\n\n\n\n\n\n\n\nRelation Type\n\n\nRelated Entity\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nbelongs\n\n\nuser\n\n\nowner of the object\n\n\n\n\n\n\nhas many\n\n\nusergroup\n\n\nbelongs to usergroup\n\n\n\n\n\n\n\n\nThese relations help you precisely control the authorization for each user.\n\n\nRead more about \nauthorization and permissions\n\n\nMultiple relation\nLink\n\n\nThere can be a scenario where two entities are related in more then 1 way. Consider the following example\n\n\n\n\nA blog entity\n\n\nA post entity\n\n\nBlog has many posts\n\n\nEach blog can have a \"highlighted post\" (blog has one \"highlighted post\")\n\n\n\n\nTo achieve the above scenario, our schema would look like as follows\n\n\nTables\n:\n\n\n-\n \nTableName\n:\n \nblog\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(500)\n\n    \nColumnType\n:\n \nlabel\n\n  \n-\n \nName\n:\n \nview_count\n\n    \nDataType\n:\n \nint(11)\n\n    \nColumnType\n:\n \nmeasurement\n\n\n-\n \nTableName\n:\n \npost\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \ntitle\n\n    \nDataType\n:\n \nvarchar(200)\n\n    \nColumnType\n:\n \nlabel\n\n  \n-\n \nName\n:\n \nbody\n\n    \nDataType\n:\n \ntext\n\n    \nColumnType\n:\n \ncontent\n\n\n-\n \nTableName\n:\n \ncomment\n\n  \nColumns\n:\n\n  \n-\n \nName\n:\n \nbody\n\n    \nDataType\n:\n \ntext\n\n    \nColumnType\n:\n \ncontent\n\n  \n-\n \nName\n:\n \nlikes_count\n\n    \nColumnName\n:\n \nlikes_count\n\n    \nDataType\n:\n \nint(11)\n\n    \nColumnType\n:\n \nmeasurement\n\n\nRelations\n:\n\n\n-\n \nSubject\n:\n \ncomment\n\n  \nRelation\n:\n \nbelongs_to\n\n  \nObject\n:\n \npost\n\n\n-\n \nSubject\n:\n \npost\n\n  \nRelation\n:\n \nbelongs_to\n\n  \nObject\n:\n \nblog                   // this is our post belongs to blog relation\n\n\n-\n \nSubject\n:\n \nblog\n\n  \nRelation\n:\n \nhas_one\n\n  \nObject\n:\n \npost\n\n  \nObjectName\n:\n \ncurrent_post\n\n  \nSubjectName\n:\n \ncurrent_post_of   // this is our highlighted post relation\n\n\n\n\n\nNotice the \"SubjectName\" and \"ObjectName\" keys which helps to name our relations more intuitively.\n\n\nSQL constraints\nLink\n\n\nbelongs to\nLink\n\n\n\n\nA column is added to the subject entity, which refers to the Object entity, set to non nullable\n\n\n\n\nhas one\nLink\n\n\n\n\nSame as above, but nullable\n\n\n\n\nhas many\nLink\n\n\n\n\nA join table is created",
            "title": "Linking data with one another"
        },
        {
            "location": "/setting-up/entity_relations/#data-relations",
            "text": "A data oriented system with no relational knowledge of the data is next to an Excel sheet. Specifying relations in your data is the most important thing after creating your entities.  Relations are constraints among tables and help you keep clean and consistent data. Relational data is easily accessible over APIs using a path structure like  /api/<entityName>/<id>/<relationName>  and the response is consistent with  JSONAPI.org .  Checkout the  relation apis  exposed by daptin.   YAML example  Relations :  -   Subject :   todo \n   Relation :   has_one \n   Object :   project     JSON example  { \n   \"Relations\" :   [ \n     { \n       \"Subject\" :   \"todo\" , \n       \"Relation\" :   \"has_one\" , \n       \"Object\" :   \"project\" \n     } \n   ]  }",
            "title": "Data relations"
        },
        {
            "location": "/setting-up/entity_relations/#relations-in-jsonyaml-schema",
            "text": "When uploading schema using a JSON / YAML file, relations can be added in the same file and daptin will create appropriate constraints and foreign keys in your underlying database.  Continuing with our example of todos, lets say we want to group todo's in \"projects\" and each todo can belong to only a single project.  Lets design a \"project\" entity:  -   TableName :   project \n   Columns : \n   -   Name :   name \n     DataType :   varchar(200) \n     ColumnType :   name \n     IsIndexed :   true   A very simple table with just a name column. Now we can tell daptin about the relation between todos and projects  Relations :  -   Subject :   todo \n   Relation :   has_one \n   Object :   project   This tells daptin that todo \"has_one\" project.",
            "title": "Relations in JSON/YAML schema"
        },
        {
            "location": "/setting-up/entity_relations/#relations-types",
            "text": "Any entity can be associated to any other entity (or to itself) as one of the follows     Relation Name  Relation Descriptio  Can be empty      belongs_to  a single object relation  No    has_one  a single object relation  Yes    has_many  many related objects  Yes",
            "title": "Relations types"
        },
        {
            "location": "/setting-up/entity_relations/#default-relations",
            "text": "Every entity created on daptin has at least two relations     Relation Type  Related Entity  Purpose      belongs  user  owner of the object    has many  usergroup  belongs to usergroup     These relations help you precisely control the authorization for each user.  Read more about  authorization and permissions",
            "title": "Default relations"
        },
        {
            "location": "/setting-up/entity_relations/#multiple-relation",
            "text": "There can be a scenario where two entities are related in more then 1 way. Consider the following example   A blog entity  A post entity  Blog has many posts  Each blog can have a \"highlighted post\" (blog has one \"highlighted post\")   To achieve the above scenario, our schema would look like as follows  Tables :  -   TableName :   blog \n   Columns : \n   -   Name :   title \n     DataType :   varchar(500) \n     ColumnType :   label \n   -   Name :   view_count \n     DataType :   int(11) \n     ColumnType :   measurement  -   TableName :   post \n   Columns : \n   -   Name :   title \n     DataType :   varchar(200) \n     ColumnType :   label \n   -   Name :   body \n     DataType :   text \n     ColumnType :   content  -   TableName :   comment \n   Columns : \n   -   Name :   body \n     DataType :   text \n     ColumnType :   content \n   -   Name :   likes_count \n     ColumnName :   likes_count \n     DataType :   int(11) \n     ColumnType :   measurement  Relations :  -   Subject :   comment \n   Relation :   belongs_to \n   Object :   post  -   Subject :   post \n   Relation :   belongs_to \n   Object :   blog                   // this is our post belongs to blog relation  -   Subject :   blog \n   Relation :   has_one \n   Object :   post \n   ObjectName :   current_post \n   SubjectName :   current_post_of   // this is our highlighted post relation   Notice the \"SubjectName\" and \"ObjectName\" keys which helps to name our relations more intuitively.",
            "title": "Multiple relation"
        },
        {
            "location": "/setting-up/entity_relations/#sql-constraints",
            "text": "",
            "title": "SQL constraints"
        },
        {
            "location": "/setting-up/entity_relations/#belongs-to",
            "text": "A column is added to the subject entity, which refers to the Object entity, set to non nullable",
            "title": "belongs to"
        },
        {
            "location": "/setting-up/entity_relations/#has-one",
            "text": "Same as above, but nullable",
            "title": "has one"
        },
        {
            "location": "/setting-up/entity_relations/#has-many",
            "text": "A join table is created",
            "title": "has many"
        },
        {
            "location": "/setting-up/database_configuration/",
            "text": "Database\nLink\n\n\nDaptin can use one of the following database for data persistence\n\n\n\n\nMysql\n\n\nPostgres\n\n\nSQLite [Default]\n\n\n\n\nIf nothing specified, a \nsqlite\n database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)\n\n\nYou can customise the database connection properties when starting daptin\n\n\nmysql\nLink\n\n\nTo use mysql, start daptin as follows\n\n\n./daptin -db_type=mysql -db_connection_string='<username>:<password>@tcp(<hostname>:<port>)/<db_name>'\n\n\npostgres\nLink\n\n\n./daptin -db_type=postgres -db_connection_string='host=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable'\n\n\nsqlite\nLink\n\n\nBy default a \"daptin.db\" file is created to store data\n\n\n./daptin -db_type=sqlite -db_connection_string=db_file_name.db",
            "title": "Database configuration"
        },
        {
            "location": "/setting-up/database_configuration/#database",
            "text": "Daptin can use one of the following database for data persistence   Mysql  Postgres  SQLite [Default]   If nothing specified, a  sqlite  database is created on the local file system and is used for all purposes. (uploads/blobs are not stored in database)  You can customise the database connection properties when starting daptin",
            "title": "Database"
        },
        {
            "location": "/setting-up/database_configuration/#mysql",
            "text": "To use mysql, start daptin as follows  ./daptin -db_type=mysql -db_connection_string='<username>:<password>@tcp(<hostname>:<port>)/<db_name>'",
            "title": "mysql"
        },
        {
            "location": "/setting-up/database_configuration/#postgres",
            "text": "./daptin -db_type=postgres -db_connection_string='host=<hostname> port=<port> user=<username> password=<password> dbname=<db_name> sslmode=enable/disable'",
            "title": "postgres"
        },
        {
            "location": "/setting-up/database_configuration/#sqlite",
            "text": "By default a \"daptin.db\" file is created to store data  ./daptin -db_type=sqlite -db_connection_string=db_file_name.db",
            "title": "sqlite"
        },
        {
            "location": "/data-modeling/data_storage/",
            "text": "Data storage\nLink\n\n\nDaptin relies on a relational database for all data persistence requirements. As covered in the installation currently the following relational database are supported:\n\n\n\n\nMySQL\n\n\nPostgreSQL\n\n\nSQLite\n\n\n\n\nThis document goes into the detail of how the database is used and what are the tables created.\n\n\nStandard columns\nLink\n\n\nThe following 5 columns are present in every table\n\n\n\n\n\n\n\n\nColumnName\n\n\nColumnType\n\n\nDataType\n\n\nAttributes\n\n\n\n\n\n\n\n\n\n\nid\n\n\nid\n\n\nint(11)\n\n\nprimary key  Auto increment Never exposed externally\n\n\n\n\n\n\nversion\n\n\ninteger\n\n\nint(11)\n\n\nget incremented every time a change is made\n\n\n\n\n\n\ncreated_at\n\n\ntimestamp\n\n\ntimestamp\n\n\nthe timestamp when the row was created\n\n\n\n\n\n\nupdated_at\n\n\ntimestamp\n\n\ntimestamp\n\n\nthe timestamp when the row was last updated\n\n\n\n\n\n\nreference_id\n\n\nalias\n\n\nvarchar(40)\n\n\nThe id exposed in APIs\n\n\n\n\n\n\npermission\n\n\ninteger\n\n\nint(4)\n\n\nPermissions - check Authorization documentation\n\n\n\n\n\n\nuser_id\n\n\nforeign key\n\n\nint(11)\n\n\nthe owner of this object\n\n\n\n\n\n\n\n\nOther columns are created based on the schema. \n\n\nThe \nid\n column is completely for internal purposes and is never exposed in an JSON API.\nEvery row of data inherently belongs to one user. This is the user who created that row. The associated user can be changed later.\n\n\nWorld table\nLink\n\n\nThe \nworld\n table holds the structure for all the entities and relations (including for itself).\n\n\nEach row contains the schema for the table in a \"world_schema_json\" column.",
            "title": "Data store format"
        },
        {
            "location": "/data-modeling/data_storage/#data-storage",
            "text": "Daptin relies on a relational database for all data persistence requirements. As covered in the installation currently the following relational database are supported:   MySQL  PostgreSQL  SQLite   This document goes into the detail of how the database is used and what are the tables created.",
            "title": "Data storage"
        },
        {
            "location": "/data-modeling/data_storage/#standard-columns",
            "text": "The following 5 columns are present in every table     ColumnName  ColumnType  DataType  Attributes      id  id  int(11)  primary key  Auto increment Never exposed externally    version  integer  int(11)  get incremented every time a change is made    created_at  timestamp  timestamp  the timestamp when the row was created    updated_at  timestamp  timestamp  the timestamp when the row was last updated    reference_id  alias  varchar(40)  The id exposed in APIs    permission  integer  int(4)  Permissions - check Authorization documentation    user_id  foreign key  int(11)  the owner of this object     Other columns are created based on the schema.   The  id  column is completely for internal purposes and is never exposed in an JSON API.\nEvery row of data inherently belongs to one user. This is the user who created that row. The associated user can be changed later.",
            "title": "Standard columns"
        },
        {
            "location": "/data-modeling/data_storage/#world-table",
            "text": "The  world  table holds the structure for all the entities and relations (including for itself).  Each row contains the schema for the table in a \"world_schema_json\" column.",
            "title": "World table"
        },
        {
            "location": "/setting-up/data_import/",
            "text": "Upload from dashboard\nLink\n\n\nUpload one of these files:\n\n\n\n\n\n\n\n\nFile\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nSchema JSON\n\n\nCreate schema and apis\n\n\n\n\n\n\nCSV\n\n\nAuto create entity and upload data\n\n\n\n\n\n\nXLSX\n\n\nAuto create entity and upload data\n\n\n\n\n\n\nData JSON\n\n\nUpload data from dumps\n\n\n\n\n\n\n\n\nExcel file upload\nLink\n\n\nExcel upload provides an easy way to create entities. This takes away the complexity of writing each column type. Daptin uses a combination of rules to identify columns and their types based on the data in the excel.\n\n\nYou can upload data from XLS. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.\n\n\nCSV file upload\nLink\n\n\nCSV upload provides an easy way to create entities. This takes away the complexity of writing each column type. Daptin uses a combination of rules to identify columns and their types based on the data in the csv.\n\n\nYou can upload data from CSV. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.",
            "title": "Import data"
        },
        {
            "location": "/setting-up/data_import/#upload-from-dashboard",
            "text": "Upload one of these files:     File  Usage      Schema JSON  Create schema and apis    CSV  Auto create entity and upload data    XLSX  Auto create entity and upload data    Data JSON  Upload data from dumps",
            "title": "Upload from dashboard"
        },
        {
            "location": "/setting-up/data_import/#excel-file-upload",
            "text": "Excel upload provides an easy way to create entities. This takes away the complexity of writing each column type. Daptin uses a combination of rules to identify columns and their types based on the data in the excel.  You can upload data from XLS. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.",
            "title": "Excel file upload"
        },
        {
            "location": "/setting-up/data_import/#csv-file-upload",
            "text": "CSV upload provides an easy way to create entities. This takes away the complexity of writing each column type. Daptin uses a combination of rules to identify columns and their types based on the data in the csv.  You can upload data from CSV. Daptin will take care of going through your XLS file and identifying column types. This is one of the easiest and fastest ways to create entities and uploading data in daptin. You can specify relations among entities later from the online designer.",
            "title": "CSV file upload"
        },
        {
            "location": "/data-modeling/data_validation/",
            "text": "Data validation\nLink\n\n\nDaptin uses the excellent \ngo-playground/validator\n library to provide extensive validations when creating and updating data.\n\n\nIt gives us the following unique features:\n\n\n\n\nCross Field and Cross Struct validations by using validation tags or custom validators.\n\n\nSlice, Array and Map diving, which allows any or all levels of a multidimensional field to be validated.",
            "title": "Data validations"
        },
        {
            "location": "/data-modeling/data_validation/#data-validation",
            "text": "Daptin uses the excellent  go-playground/validator  library to provide extensive validations when creating and updating data.  It gives us the following unique features:   Cross Field and Cross Struct validations by using validation tags or custom validators.  Slice, Array and Map diving, which allows any or all levels of a multidimensional field to be validated.",
            "title": "Data validation"
        },
        {
            "location": "/data-modeling/data_conformation/",
            "text": "Data conformations\nLink\n\n\nDaptin uses the excellent \nleebenson/conform\n library to apply conformations on data before storing them in the database\n\n\n\n\nConform: keep user input in check (go, golang)\n\n\nTrim, sanitize, and modify struct string fields in place, based on tags.\n\n\n\n\nUse it for names, e-mail addresses, URL slugs, or any other form field where formatting matters.\n\n\nConform doesn't attempt any kind of validation on your fields.",
            "title": "Data conformations"
        },
        {
            "location": "/data-modeling/data_conformation/#data-conformations",
            "text": "Daptin uses the excellent  leebenson/conform  library to apply conformations on data before storing them in the database   Conform: keep user input in check (go, golang)  Trim, sanitize, and modify struct string fields in place, based on tags.   Use it for names, e-mail addresses, URL slugs, or any other form field where formatting matters.  Conform doesn't attempt any kind of validation on your fields.",
            "title": "Data conformations"
        },
        {
            "location": "/data-modeling/auditing/",
            "text": "Data Audits\nLink\n\n\nTo enable recoding of all historical data for a particular entity, enable data audit for it in the worlds configuration.\n\n\nAudits are ready only and cannot be manipulated over api. You can configure the permission for your use case.\n\n\nAll changes in daptin can be recorded by enabling \nauditing\n. History is maintained in separate audit tables which maintain a copy of all columns at each change. Audit table are entities just like regular entities. All Patch/Put/Delete calls to daptin will create an entry in the audit table if the entity is changed.\n\n\nAudit tables\nLink\n\n\nFor any entity named \n<X>\n, another tables \n<X>_audit\n is added by daptin. Eg if you enable auditing of the \nuser\n table, then a \nuser_audit\n table will be created.\n\n\nThe audit table will contain all the columns which are present in the original table, plus an extra column \nis_audit_of\n is added, which contains the ID of the original row. The \nis_audit_of\n is a foreign key column to the parent tables \nid\n column.\n\n\nAudit row\nLink\n\n\nEach row in the audit table is the copy of the original row just before it is being modified. The audit rows can be accessed just like any other relation.\n\n\nAudit table permissions\nLink\n\n\nBy default, everyone has the access to create audit row, and no one has the access to update or delete them. These permissions can be changed, but it is not recommended at present.\n\n\n\n\n\n\n\n\nType\n\n\nPermission\n\n\n\n\n\n\n\n\n\n\nAudit table permission\n\n\n007007007\n\n\n\n\n\n\nAudit object permission\n\n\n003003003",
            "title": "Audit"
        },
        {
            "location": "/data-modeling/auditing/#data-audits",
            "text": "To enable recoding of all historical data for a particular entity, enable data audit for it in the worlds configuration.  Audits are ready only and cannot be manipulated over api. You can configure the permission for your use case.  All changes in daptin can be recorded by enabling  auditing . History is maintained in separate audit tables which maintain a copy of all columns at each change. Audit table are entities just like regular entities. All Patch/Put/Delete calls to daptin will create an entry in the audit table if the entity is changed.",
            "title": "Data Audits"
        },
        {
            "location": "/data-modeling/auditing/#audit-tables",
            "text": "For any entity named  <X> , another tables  <X>_audit  is added by daptin. Eg if you enable auditing of the  user  table, then a  user_audit  table will be created.  The audit table will contain all the columns which are present in the original table, plus an extra column  is_audit_of  is added, which contains the ID of the original row. The  is_audit_of  is a foreign key column to the parent tables  id  column.",
            "title": "Audit tables"
        },
        {
            "location": "/data-modeling/auditing/#audit-row",
            "text": "Each row in the audit table is the copy of the original row just before it is being modified. The audit rows can be accessed just like any other relation.",
            "title": "Audit row"
        },
        {
            "location": "/data-modeling/auditing/#audit-table-permissions",
            "text": "By default, everyone has the access to create audit row, and no one has the access to update or delete them. These permissions can be changed, but it is not recommended at present.     Type  Permission      Audit table permission  007007007    Audit object permission  003003003",
            "title": "Audit table permissions"
        },
        {
            "location": "/data-modeling/state_tracking/",
            "text": "State tracking for entities\nLink\n\n\nTracking the status of things is one of the most common operation in most business flows. Daptin has a native support for state tracking and allows a lot of convienent features.\n\n\nState machine\nLink\n\n\nA state machine is a description of \"states\" which the object can be in, and list of all valid transitions from one state to another. Let us begin with an example:\n\n\nThe following JSON defines a state machine which has (a hypothetical state machine for tracking todos):\n\n\n\n\nInitial state: to_be_done\n\n\nList of valid states: to_be_done, delayed, started, ongoing, interrupted, completed\n\n\nList of valid transitions, giving name to each event\n\n\n\n\n        \n{\n\n        \n\"Name\"\n:\n \n\"task_status\"\n,\n\n        \n\"Label\"\n:\n \n\"Task Status\"\n,\n\n        \n\"InitialState\"\n:\n \n\"to_be_done\"\n,\n\n        \n\"Events\"\n:\n \n[{\n\n                \n\"Name\"\n:\n \n\"start\"\n,\n\n                \n\"Label\"\n:\n \n\"Start\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"to_be_done\"\n,\n\n                    \n\"delayed\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"started\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"delayed\"\n,\n\n                \n\"Label\"\n:\n \n\"Unable to pick up\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"to_be_done\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"delayed\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"ongoing\"\n,\n\n                \n\"Label\"\n:\n \n\"Record progress\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"started\"\n,\n\n                    \n\"ongoing\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"ongoing\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"interrupted\"\n,\n\n                \n\"Label\"\n:\n \n\"Interrupted\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"started\"\n,\n\n                    \n\"ongoing\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"interrupted\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"resume\"\n,\n\n                \n\"Label\"\n:\n \n\"Resume from interruption\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"interrupted\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"ongoing\"\n\n            \n},\n\n            \n{\n\n                \n\"Name\"\n:\n \n\"completed\"\n,\n\n                \n\"Label\"\n:\n \n\"Mark as completed\"\n,\n\n                \n\"Src\"\n:\n \n[\n\n                    \n\"ongoing\"\n,\n\n                    \n\"started\"\n\n                \n],\n\n                \n\"Dst\"\n:\n \n\"completed\"\n\n            \n}\n\n        \n]\n\n    \n}\n\n\n\n\n\nState machines can be uploaded to Daptin just like entities and actions. A JSON/YAML file with a \nStateMachineDescriptions\n top level key can contain an array of state machine descriptions.\n\n\nREST API\nLink\n\n\nStart tracking an object by state machine reference id\nLink\n\n\nRequest\n\n    POST  /track/start/:stateMachineId\n    {\"typeName\": <entityTypeName>, \"referenceId\": <ReferenceIdOfTheObject> }\n\n\n\nResponse\n\n        \"current_state\": <InitialStateOfTheStateMachine>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>\n        \"permission\": <AuthPermission>\n\n\n\nTrigger an event by name in the state of an object\nLink\n\n\n    POST  /track/event/:typename/:ObjectStateInstanceReferenceId/:eventName\n\n\nResponse\n\n        \"current_state\": <NewStateAfterEvent>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>\n\n\n\nEnabling state tracking for entity\nLink\n\n\nBegin with marking an entity as trackable. To do this, \n\n\n\n\n\n\ngo to the world tables page and edit the an entity\n\n\n\n\n\n\nCheck the \"Is state tracking enabled\" checkbox\n\n\n\n\n\n\nThis \"is_state_tracking_enabled\" options tells daptin to create the associated state table for the entity. Even though we have not yet specified which state machines are available for this entity.\n\n\nTo make a state machine available for an entity, go to the \"SMD\" tab of this entity on the same page and add the state machine by searching it by name and adding it.\n\n\nIt would not make a lot of sense if the above state machine was allowed for all type of entities.",
            "title": "State tracking"
        },
        {
            "location": "/data-modeling/state_tracking/#state-tracking-for-entities",
            "text": "Tracking the status of things is one of the most common operation in most business flows. Daptin has a native support for state tracking and allows a lot of convienent features.",
            "title": "State tracking for entities"
        },
        {
            "location": "/data-modeling/state_tracking/#state-machine",
            "text": "A state machine is a description of \"states\" which the object can be in, and list of all valid transitions from one state to another. Let us begin with an example:  The following JSON defines a state machine which has (a hypothetical state machine for tracking todos):   Initial state: to_be_done  List of valid states: to_be_done, delayed, started, ongoing, interrupted, completed  List of valid transitions, giving name to each event            { \n         \"Name\" :   \"task_status\" , \n         \"Label\" :   \"Task Status\" , \n         \"InitialState\" :   \"to_be_done\" , \n         \"Events\" :   [{ \n                 \"Name\" :   \"start\" , \n                 \"Label\" :   \"Start\" , \n                 \"Src\" :   [ \n                     \"to_be_done\" , \n                     \"delayed\" \n                 ], \n                 \"Dst\" :   \"started\" \n             }, \n             { \n                 \"Name\" :   \"delayed\" , \n                 \"Label\" :   \"Unable to pick up\" , \n                 \"Src\" :   [ \n                     \"to_be_done\" \n                 ], \n                 \"Dst\" :   \"delayed\" \n             }, \n             { \n                 \"Name\" :   \"ongoing\" , \n                 \"Label\" :   \"Record progress\" , \n                 \"Src\" :   [ \n                     \"started\" , \n                     \"ongoing\" \n                 ], \n                 \"Dst\" :   \"ongoing\" \n             }, \n             { \n                 \"Name\" :   \"interrupted\" , \n                 \"Label\" :   \"Interrupted\" , \n                 \"Src\" :   [ \n                     \"started\" , \n                     \"ongoing\" \n                 ], \n                 \"Dst\" :   \"interrupted\" \n             }, \n             { \n                 \"Name\" :   \"resume\" , \n                 \"Label\" :   \"Resume from interruption\" , \n                 \"Src\" :   [ \n                     \"interrupted\" \n                 ], \n                 \"Dst\" :   \"ongoing\" \n             }, \n             { \n                 \"Name\" :   \"completed\" , \n                 \"Label\" :   \"Mark as completed\" , \n                 \"Src\" :   [ \n                     \"ongoing\" , \n                     \"started\" \n                 ], \n                 \"Dst\" :   \"completed\" \n             } \n         ] \n     }   State machines can be uploaded to Daptin just like entities and actions. A JSON/YAML file with a  StateMachineDescriptions  top level key can contain an array of state machine descriptions.",
            "title": "State machine"
        },
        {
            "location": "/data-modeling/state_tracking/#rest-api",
            "text": "",
            "title": "REST API"
        },
        {
            "location": "/data-modeling/state_tracking/#start-tracking-an-object-by-state-machine-reference-id",
            "text": "Request     POST  /track/start/:stateMachineId\n    {\"typeName\": <entityTypeName>, \"referenceId\": <ReferenceIdOfTheObject> }  Response         \"current_state\": <InitialStateOfTheStateMachine>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>\n        \"permission\": <AuthPermission>",
            "title": "Start tracking an object by state machine reference id"
        },
        {
            "location": "/data-modeling/state_tracking/#trigger-an-event-by-name-in-the-state-of-an-object",
            "text": "POST  /track/event/:typename/:ObjectStateInstanceReferenceId/:eventName \nResponse         \"current_state\": <NewStateAfterEvent>\n        \"<typename>_smd\": <ObjectStateInstanceReferenceId>\n        \"is_state_of_<typename>\" = <ObjectInstanceId>",
            "title": "Trigger an event by name in the state of an object"
        },
        {
            "location": "/data-modeling/state_tracking/#enabling-state-tracking-for-entity",
            "text": "Begin with marking an entity as trackable. To do this,     go to the world tables page and edit the an entity    Check the \"Is state tracking enabled\" checkbox    This \"is_state_tracking_enabled\" options tells daptin to create the associated state table for the entity. Even though we have not yet specified which state machines are available for this entity.  To make a state machine available for an entity, go to the \"SMD\" tab of this entity on the same page and add the state machine by searching it by name and adding it.  It would not make a lot of sense if the above state machine was allowed for all type of entities.",
            "title": "Enabling state tracking for entity"
        },
        {
            "location": "/extend/data_exchange/",
            "text": "Data Exchanges \nLink\n\n\nExchanges are internal hooks to external apis, to either push data and update an external service, or pull data and update itself from some external service.\n\n\nExample, use exchange to sync data creation call to Google Sheets. So on every row created using the POST API also creates a corresponding row in your google sheet.\n\n\n\n\nGoogle drive exchange YAML\n\n\nExchanges\n:\n\n\n-\n \nName\n:\n \nTask to excel sheet\n\n  \nSourceAttributes\n:\n\n    \nName\n:\n \ntodo\n\n  \nSourceType\n:\n \nself\n\n  \nTargetAttributes\n:\n\n    \nsheetUrl\n:\n \nhttps://content-sheets.googleapis.com/v4/spreadsheets/1Ru-bDk3AjQotQj72k8SyxoOs84eXA1Y6sSPumBb3WSA/values/A1:append\n\n    \nappKey\n:\n \nAIzaSyAC2xame4NShrzH9ZJeEpWT5GkySooa0XM\n\n  \nTargetType\n:\n \ngsheet-append\n\n  \nAttributes\n:\n\n  \n-\n \nSourceColumn\n:\n \n\"$self.description\"\n\n    \nTargetColumn\n:\n \nTask description\n\n  \n-\n \nSourceColumn\n:\n \nself.schedule\n\n    \nTargetColumn\n:\n \nScheduled at\n\n  \nOptions\n:\n\n    \nhasHeader\n:\n \ntrue",
            "title": "Data exchange and sync"
        },
        {
            "location": "/extend/data_exchange/#data-exchanges",
            "text": "Exchanges are internal hooks to external apis, to either push data and update an external service, or pull data and update itself from some external service.  Example, use exchange to sync data creation call to Google Sheets. So on every row created using the POST API also creates a corresponding row in your google sheet.   Google drive exchange YAML  Exchanges :  -   Name :   Task to excel sheet \n   SourceAttributes : \n     Name :   todo \n   SourceType :   self \n   TargetAttributes : \n     sheetUrl :   https://content-sheets.googleapis.com/v4/spreadsheets/1Ru-bDk3AjQotQj72k8SyxoOs84eXA1Y6sSPumBb3WSA/values/A1:append \n     appKey :   AIzaSyAC2xame4NShrzH9ZJeEpWT5GkySooa0XM \n   TargetType :   gsheet-append \n   Attributes : \n   -   SourceColumn :   \"$self.description\" \n     TargetColumn :   Task description \n   -   SourceColumn :   self.schedule \n     TargetColumn :   Scheduled at \n   Options : \n     hasHeader :   true",
            "title": "Data Exchanges "
        },
        {
            "location": "/streams/streams/",
            "text": "Streams\nLink\n\n\nStreams are complimentary to \nactions\n. Think of streams as views in SQL. A stream is basically one entity + set of transformations and filters on the entity. Streams are read-only and exposed with similar semantics of that of entities. Daptin will expose JSONAPI for each stream just like it does for entities.\n\n\nHere is an example of a stream which exposes list of completed todos only\n\n\n{\n        StreamName:     \"transformed_user\",\n        RootEntityName: \"todo\",\n        Columns: []api2go.ColumnInfo{          // List of columns in this stream\n            {\n                Name:       \"transformed_todo_title\",  \n                ColumnType: \"label\",\n            },\n            {\n                Name:       \"completed_on\",\n                ColumnType: \"datetime\",\n            },\n        },\n        QueryParams: QueryParams{\n            \"Filter\": \"completed=true\",\n            \"Select\": \"title,deadline\",\n        },\n        Transformations: []Transformation{\n            {\n                Operation: \"select\",\n                Attributes: map[string]interface{}{\n                    \"columns\": []string{\"title\", \"deadline\"},\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"title\",\n                    \"newName\": \"transformed_todo_title\",\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"deadline\",\n                    \"newName\": \"completed_on\",\n                },\n            },\n        },\n}   \n\n\n\n\nDaptin uses the library \nkniren/gota\n to systematically specific list of transformations which are applied to the original data stream.",
            "title": "Data streams"
        },
        {
            "location": "/streams/streams/#streams",
            "text": "Streams are complimentary to  actions . Think of streams as views in SQL. A stream is basically one entity + set of transformations and filters on the entity. Streams are read-only and exposed with similar semantics of that of entities. Daptin will expose JSONAPI for each stream just like it does for entities.  Here is an example of a stream which exposes list of completed todos only  {\n        StreamName:     \"transformed_user\",\n        RootEntityName: \"todo\",\n        Columns: []api2go.ColumnInfo{          // List of columns in this stream\n            {\n                Name:       \"transformed_todo_title\",  \n                ColumnType: \"label\",\n            },\n            {\n                Name:       \"completed_on\",\n                ColumnType: \"datetime\",\n            },\n        },\n        QueryParams: QueryParams{\n            \"Filter\": \"completed=true\",\n            \"Select\": \"title,deadline\",\n        },\n        Transformations: []Transformation{\n            {\n                Operation: \"select\",\n                Attributes: map[string]interface{}{\n                    \"columns\": []string{\"title\", \"deadline\"},\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"title\",\n                    \"newName\": \"transformed_todo_title\",\n                },\n            },\n            {\n                Operation: \"rename\",\n                Attributes: map[string]interface{}{\n                    \"oldName\": \"deadline\",\n                    \"newName\": \"completed_on\",\n                },\n            },\n        },\n}     Daptin uses the library  kniren/gota  to systematically specific list of transformations which are applied to the original data stream.",
            "title": "Streams"
        },
        {
            "location": "/apis/read/",
            "text": "",
            "title": "Read, search, filter"
        },
        {
            "location": "/apis/create/",
            "text": "",
            "title": "Create"
        },
        {
            "location": "/apis/update/",
            "text": "",
            "title": "Update"
        },
        {
            "location": "/apis/delete/",
            "text": "",
            "title": "Delete"
        },
        {
            "location": "/apis/relation/",
            "text": "Relations\nLink",
            "title": "Relations"
        },
        {
            "location": "/apis/relation/#relations",
            "text": "",
            "title": "Relations"
        },
        {
            "location": "/apis/execute/",
            "text": "",
            "title": "Execute"
        },
        {
            "location": "/actions/actions/",
            "text": "Actions\nLink\n\n\nActions are the most useful things in Daptin and we will see that everything you have done in Daptin was as action itself.\n\n\nActions can be thought of as follows:\n\n\n\n\nA set of inputs\n\n\nA set of outcomes based on the inputs\n\n\n\n\nWhat are actions and why do I need this\nLink\n\n\nCreate/Read/Update/Delete (CRUD) APIs are only the most basic apis exposed on the database, and you would rarely want to make those API available to your end user. Reasons could be multiple\n\n\n\n\nThe end user doesn't (immediately) owe the data they create\n\n\nCreating a \"row\"/\"data entry\" entry doesnt signify completion of a process or a flow\n\n\nUsually a \"set of entities\" is to created and not just a single entity (when you create a user, you also want to create a usergroup also and associate the user to usergroup)\n\n\nYou could allow user to update only some fields of an entity and not all fields (eg user can change their name, but not email)\n\n\nChanges based on some entity (when you are going though a project, a new todo should automatically belong to that project)\n\n\n\n\nActions provide a powerful abstraction over the CRUD and handle all of these use cases.\n\n\nTo quickly understand what actions are, lets see what happened when you \"signed up\" on Daptin.\n\n\nLets take a look at how \"Sign up\" action is defined in Daptin. We will go through each part of this definition\nAn action is performed on an entity. Lets also remember that \nworld\n is an entity itself.\n\n\nAction schema\nLink\n\n\n    {\n        Name:             \"signup\",\n        Label:            \"Sign up\",\n        InstanceOptional: true,\n        OnType:           \"user\",\n        InFields: []api2go.ColumnInfo{\n            {\n                Name:       \"name\",\n                ColumnName: \"name\",\n                ColumnType: \"label\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"email\",\n                ColumnName: \"email\",\n                ColumnType: \"email\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"password\",\n                ColumnName: \"password\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"Password Confirm\",\n                ColumnName: \"passwordConfirm\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n        },\n        Validations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"required\",\n            },\n            {\n                ColumnName: \"password\",\n                Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n            },\n        },\n        Conformations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"trim\",\n            },\n        },\n        OutFields: {\n            {\n                Type:      \"user\",\n                Method:    \"POST\",\n                Reference: \"user\",\n                Attributes: {\n                    \"name\":      \"~name\",\n                    \"email\":     \"~email\",\n                    \"password\":  \"~password\",\n                    \"confirmed\": \"0\",\n                },\n            },\n            {\n                Type:      \"usergroup\",\n                Method:    \"POST\",\n                Reference: \"usergroup\",\n                Attributes: {\n                    \"name\": \"!'Home group for ' + user.name\",\n                },\n            },\n            {\n                Type:      \"user_user_id_has_usergroup_usergroup_id\",\n                Method:    \"POST\",\n                Reference: \"user_usergroup\",\n                Attributes: {\n                    \"user_id\":      \"$user.reference_id\",\n                    \"usergroup_id\": \"$usergroup.reference_id\",\n                },\n            },\n            {\n                Type:   \"client.notify\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"type\":    \"success\",\n                    \"title\":   \"Success\",\n                    \"message\": \"Signup Successful\",\n                },\n            },\n            {\n                Type:   \"client.redirect\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"location\": \"/auth/signin\",\n                    \"window\":   \"self\",\n                },\n            },\n        },\n    }\n\n\n\n\nAction Name\nLink\n\n\n    Name:             \"signup\",\n\n\n\n\n\nName of the action, this should be unique for each actions. Actions are identified by this name\n\n\nAction Label\nLink\n\n\n    Label:            \"Sign up\",\n\n\n\n\n\nLabel is for humans\n\n\nOnType\nLink\n\n\n    OnType:           \"user\",\n\n\n\n\n\nThe primary type of entity on which the action happens. This is used to know where the actions should come up on the UI\n\n\nAction instance\nLink\n\n\n    InstanceOptional: true,\n\n\n\n\n\nIf the action requires an \"instance\" of that type on which the action is defined (more about this below). So \"Sign up\" is defined on \"user\" table, but an instance of \"user\" is not required to initiate the action. This is why the \"Sign up\" doesnt ask you to select a user (which wouldn't make sense either)\n\n\nInput fields\nLink\n\n\n    InFields: []api2go.ColumnInfo\n\n\n\n\n\nThis is a set of inputs which the user need to fill in to initiate that action. As we see here in case of \"Sign up\", we ask for four inputs\n\n\n\n\nName\n\n\nEmail\n\n\nPassword\n\n\nConfirm password\n\n\n\n\nNote that the ColumnInfo structure is the same one we used to \ndefine tables\n.\n\n\nValidations\nLink\n\n\n    Validations: []ColumnTag\n\n\n\n\n\nValidations validate the user input and rejects if some validation fails\n\n\n  {\n            ColumnName: \"email\",\n            Tags:       \"email\",\n        },\n\n\n\n\n\nThis tells that the \"email\" input should actually be an email.\n\n\nOne of the more interesting validations is cross field check\n\n\n        {\n            ColumnName: \"password\",\n            Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n        },\n\n\n\n\n\nThis tells that the value entered by user in the password field should be equal to the value in passwordConfirm field. And the minimum length should be 8 characters.\n\n\nConformations\nLink\n\n\n    Conformations: []ColumnTag\n\n\n\n\n\nConformations help to clean the data before the action is carried out. The frequently one used are \ntrim\n and \nemail\n.\n\n\n\n\nTrim: trim removes white spaces, which are sometimes accidently introduced when entering data\n\n\nEmail: email conformation will normalize the email. Things like lowercase + trim\n\n\n\n\nOutFields\nLink\n\n\n    OutFields: []Outcome\n\n\n\n\n\nOutFields are the list of outcomes which the action will result in. The outcomes are evaluated in a top to bottom manner, and the result of one outcome is accessible when evaluating the next outcome.\n\n\nWe have defined three outcomes in our \"Sign Up\" action.\n\n\n\n\nCreate a user\n    {\n        Type:      \"user\",\n        Method:    \"POST\",\n        Reference: \"user\",\n        Attributes: map[string]interface{}{\n            \"name\":      \"~name\",\n            \"email\":     \"~email\",\n            \"password\":  \"~password\",\n            \"confirmed\": \"0\",\n        },\n    },\n\n\n\n\n\n\n\n\n\nThis tells us that, the first outcome is of type \"user\". The outcome is a \"New User\" (POST). It could alternatively have been a Update/Find/Delete operation.\n\n\nThe attributes maps the input fields to the fields of our new user.\n\n\n\n\n~name\n will be the value entered by user in the name field\n\n\n~email\n will be the entered in the email field, and so on\n\n\n\n\nIf we skip the \n~\n, like \n\"confirmed\": \"0\"\n Then the literal value is used.\n\n\nReference: \"user\",\n We have this to allow the \"outcome\" to be referenced when evaluating the next outcome. Let us see the other outcomes\n\n\nScripted fields - \"!...\"\nLink\n\n\n        {\n            Type:      \"usergroup\",\n            Method:    \"POST\",\n            Reference: \"usergroup\",\n            Attributes: map[string]interface{}{\n                \"name\": \"!'Home group for ' + user.name\",\n            },\n        },\n\n\n\n\n\nDaptin includes the \notto js engine\n. An exclamation mark tell daptin to evaluate the rest of the string as Javascript.\n\n\n'Home group for ' + user.name\n becomes \"Home group for parth\"\n\n\nReferencing previous outcomes\nLink\n\n\n        {\n            Type:      \"user_user_id_has_usergroup_usergroup_id\",\n            Method:    \"POST\",\n            Reference: \"user_usergroup\",\n            Attributes: map[string]interface{}{\n                \"user_id\":      \"$user.reference_id\",\n                \"usergroup_id\": \"$usergroup.reference_id\",\n            },\n        },\n\n\n\n\n\nthe \n$\n sign is to refer the previous outcomes. Here this outcome adds the newly created user to the newly created usergroup.",
            "title": "Using actions"
        },
        {
            "location": "/actions/actions/#actions",
            "text": "Actions are the most useful things in Daptin and we will see that everything you have done in Daptin was as action itself.  Actions can be thought of as follows:   A set of inputs  A set of outcomes based on the inputs",
            "title": "Actions"
        },
        {
            "location": "/actions/actions/#what-are-actions-and-why-do-i-need-this",
            "text": "Create/Read/Update/Delete (CRUD) APIs are only the most basic apis exposed on the database, and you would rarely want to make those API available to your end user. Reasons could be multiple   The end user doesn't (immediately) owe the data they create  Creating a \"row\"/\"data entry\" entry doesnt signify completion of a process or a flow  Usually a \"set of entities\" is to created and not just a single entity (when you create a user, you also want to create a usergroup also and associate the user to usergroup)  You could allow user to update only some fields of an entity and not all fields (eg user can change their name, but not email)  Changes based on some entity (when you are going though a project, a new todo should automatically belong to that project)   Actions provide a powerful abstraction over the CRUD and handle all of these use cases.  To quickly understand what actions are, lets see what happened when you \"signed up\" on Daptin.  Lets take a look at how \"Sign up\" action is defined in Daptin. We will go through each part of this definition\nAn action is performed on an entity. Lets also remember that  world  is an entity itself.",
            "title": "What are actions and why do I need this"
        },
        {
            "location": "/actions/actions/#action-schema",
            "text": "{\n        Name:             \"signup\",\n        Label:            \"Sign up\",\n        InstanceOptional: true,\n        OnType:           \"user\",\n        InFields: []api2go.ColumnInfo{\n            {\n                Name:       \"name\",\n                ColumnName: \"name\",\n                ColumnType: \"label\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"email\",\n                ColumnName: \"email\",\n                ColumnType: \"email\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"password\",\n                ColumnName: \"password\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n            {\n                Name:       \"Password Confirm\",\n                ColumnName: \"passwordConfirm\",\n                ColumnType: \"password\",\n                IsNullable: false,\n            },\n        },\n        Validations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"required\",\n            },\n            {\n                ColumnName: \"password\",\n                Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n            },\n        },\n        Conformations: []ColumnTag{\n            {\n                ColumnName: \"email\",\n                Tags:       \"email\",\n            },\n            {\n                ColumnName: \"name\",\n                Tags:       \"trim\",\n            },\n        },\n        OutFields: {\n            {\n                Type:      \"user\",\n                Method:    \"POST\",\n                Reference: \"user\",\n                Attributes: {\n                    \"name\":      \"~name\",\n                    \"email\":     \"~email\",\n                    \"password\":  \"~password\",\n                    \"confirmed\": \"0\",\n                },\n            },\n            {\n                Type:      \"usergroup\",\n                Method:    \"POST\",\n                Reference: \"usergroup\",\n                Attributes: {\n                    \"name\": \"!'Home group for ' + user.name\",\n                },\n            },\n            {\n                Type:      \"user_user_id_has_usergroup_usergroup_id\",\n                Method:    \"POST\",\n                Reference: \"user_usergroup\",\n                Attributes: {\n                    \"user_id\":      \"$user.reference_id\",\n                    \"usergroup_id\": \"$usergroup.reference_id\",\n                },\n            },\n            {\n                Type:   \"client.notify\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"type\":    \"success\",\n                    \"title\":   \"Success\",\n                    \"message\": \"Signup Successful\",\n                },\n            },\n            {\n                Type:   \"client.redirect\",\n                Method: \"ACTIONRESPONSE\",\n                Attributes: {\n                    \"location\": \"/auth/signin\",\n                    \"window\":   \"self\",\n                },\n            },\n        },\n    }",
            "title": "Action schema"
        },
        {
            "location": "/actions/actions/#action-name",
            "text": "Name:             \"signup\",  Name of the action, this should be unique for each actions. Actions are identified by this name",
            "title": "Action Name"
        },
        {
            "location": "/actions/actions/#action-label",
            "text": "Label:            \"Sign up\",  Label is for humans",
            "title": "Action Label"
        },
        {
            "location": "/actions/actions/#ontype",
            "text": "OnType:           \"user\",  The primary type of entity on which the action happens. This is used to know where the actions should come up on the UI",
            "title": "OnType"
        },
        {
            "location": "/actions/actions/#action-instance",
            "text": "InstanceOptional: true,  If the action requires an \"instance\" of that type on which the action is defined (more about this below). So \"Sign up\" is defined on \"user\" table, but an instance of \"user\" is not required to initiate the action. This is why the \"Sign up\" doesnt ask you to select a user (which wouldn't make sense either)",
            "title": "Action instance"
        },
        {
            "location": "/actions/actions/#input-fields",
            "text": "InFields: []api2go.ColumnInfo  This is a set of inputs which the user need to fill in to initiate that action. As we see here in case of \"Sign up\", we ask for four inputs   Name  Email  Password  Confirm password   Note that the ColumnInfo structure is the same one we used to  define tables .",
            "title": "Input fields"
        },
        {
            "location": "/actions/actions/#validations",
            "text": "Validations: []ColumnTag  Validations validate the user input and rejects if some validation fails    {\n            ColumnName: \"email\",\n            Tags:       \"email\",\n        },  This tells that the \"email\" input should actually be an email.  One of the more interesting validations is cross field check          {\n            ColumnName: \"password\",\n            Tags:       \"eqfield=InnerStructField[passwordConfirm],min=8\",\n        },  This tells that the value entered by user in the password field should be equal to the value in passwordConfirm field. And the minimum length should be 8 characters.",
            "title": "Validations"
        },
        {
            "location": "/actions/actions/#conformations",
            "text": "Conformations: []ColumnTag  Conformations help to clean the data before the action is carried out. The frequently one used are  trim  and  email .   Trim: trim removes white spaces, which are sometimes accidently introduced when entering data  Email: email conformation will normalize the email. Things like lowercase + trim",
            "title": "Conformations"
        },
        {
            "location": "/actions/actions/#outfields",
            "text": "OutFields: []Outcome  OutFields are the list of outcomes which the action will result in. The outcomes are evaluated in a top to bottom manner, and the result of one outcome is accessible when evaluating the next outcome.  We have defined three outcomes in our \"Sign Up\" action.   Create a user     {\n        Type:      \"user\",\n        Method:    \"POST\",\n        Reference: \"user\",\n        Attributes: map[string]interface{}{\n            \"name\":      \"~name\",\n            \"email\":     \"~email\",\n            \"password\":  \"~password\",\n            \"confirmed\": \"0\",\n        },\n    },    This tells us that, the first outcome is of type \"user\". The outcome is a \"New User\" (POST). It could alternatively have been a Update/Find/Delete operation.  The attributes maps the input fields to the fields of our new user.   ~name  will be the value entered by user in the name field  ~email  will be the entered in the email field, and so on   If we skip the  ~ , like  \"confirmed\": \"0\"  Then the literal value is used.  Reference: \"user\",  We have this to allow the \"outcome\" to be referenced when evaluating the next outcome. Let us see the other outcomes",
            "title": "OutFields"
        },
        {
            "location": "/actions/actions/#scripted-fields-",
            "text": "{\n            Type:      \"usergroup\",\n            Method:    \"POST\",\n            Reference: \"usergroup\",\n            Attributes: map[string]interface{}{\n                \"name\": \"!'Home group for ' + user.name\",\n            },\n        },  Daptin includes the  otto js engine . An exclamation mark tell daptin to evaluate the rest of the string as Javascript.  'Home group for ' + user.name  becomes \"Home group for parth\"",
            "title": "Scripted fields - \"!...\""
        },
        {
            "location": "/actions/actions/#referencing-previous-outcomes",
            "text": "{\n            Type:      \"user_user_id_has_usergroup_usergroup_id\",\n            Method:    \"POST\",\n            Reference: \"user_usergroup\",\n            Attributes: map[string]interface{}{\n                \"user_id\":      \"$user.reference_id\",\n                \"usergroup_id\": \"$usergroup.reference_id\",\n            },\n        },  the  $  sign is to refer the previous outcomes. Here this outcome adds the newly created user to the newly created usergroup.",
            "title": "Referencing previous outcomes"
        },
        {
            "location": "/actions/default_actions/",
            "text": "Actions\nLink\n\n\nUse actions to build work flows to carry out tasks like syncing data or emailing your users. You can also give access to these workflows to your users and restrict their access by altering their \npermission\n.\n\n\nRestart daptin\nLink\n\n\nRestarts daptin immediately and reads file system for new config and data files and apply updates to the APIs as necessary.\n\n\nTakes about 15 seconds (async) to reconfigure everything.\n\n\nvar\n \nrequest\n \n=\n \nrequire\n(\n'request'\n);\n\n\n\nvar\n \nheaders\n \n=\n \n{\n\n    \n'Authorization'\n:\n \n'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFydHBhcjFAZ21haWwuY29tIiwiZXhwIjoxNTIzMTgzMTA0LCJpYXQiOiIyMDE4LTA0LTA1VDE1OjU1OjA0LjYyMzU4NTYxKzA1OjMwIiwiaXNzIjoiZGFwdGluIiwianRpIjoiNmJhMmFhZjgtODBlNS00OGIwLTgwZmItMzEzYzk3Nzg0Y2E4IiwibmFtZSI6InBhcnRoIiwibmJmIjoxNTIyOTIzOTA0LCJwaWN0dXJlIjoiaHR0cHM6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci9mNGJmNmI2Nzg5NGU5MzAzYjZlMTczMTMyZWE0ZTkwYVx1MDAyNmQ9bW9uc3RlcmlkIn0.eb5Vp00cHLeshZBtwJIyarJ6RQOLeVPj15n8ubVnGYo'\n\n\n};\n\n\n\nvar\n \ndataString\n \n=\n \n'{\"attributes\":{}}'\n;\n\n\n\nvar\n \noptions\n \n=\n \n{\n\n    \nurl\n:\n \n'http://api.daptin.com:6336/action/world/restart_daptin'\n,\n\n    \nmethod\n:\n \n'POST'\n,\n\n    \nheaders\n: \nheaders\n,\n\n    \nbody\n: \ndataString\n\n\n};\n\n\n\nfunction\n \ncallback\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n    \nif\n \n(\n!\nerror\n \n&&\n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n        \nconsole\n.\nlog\n(\nbody\n);\n\n    \n}\n\n\n}\n\n\n\nrequest\n(\noptions\n,\n \ncallback\n);\n\n\n\n\n\nRefresh marketplace packages\nLink\n\n\nPull updates from marketplace repository. New changes are not applied immediately and these packages should be installed again for updates.\n\n\nvar\n \nrequest\n \n=\n \nrequire\n(\n'request'\n);\n\n\n\nvar\n \nheaders\n \n=\n \n{\n\n    \n'Authorization'\n:\n \n'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFydHBhcjFAZ21haWwuY29tIiwiZXhwIjoxNTIzMTgzMTA0LCJpYXQiOiIyMDE4LTA0LTA1VDE1OjU1OjA0LjYyMzU4NTYxKzA1OjMwIiwiaXNzIjoiZGFwdGluIiwianRpIjoiNmJhMmFhZjgtODBlNS00OGIwLTgwZmItMzEzYzk3Nzg0Y2E4IiwibmFtZSI6InBhcnRoIiwibmJmIjoxNTIyOTIzOTA0LCJwaWN0dXJlIjoiaHR0cHM6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci9mNGJmNmI2Nzg5NGU5MzAzYjZlMTczMTMyZWE0ZTkwYVx1MDAyNmQ9bW9uc3RlcmlkIn0.eb5Vp00cHLeshZBtwJIyarJ6RQOLeVPj15n8ubVnGYo'\n\n\n};\n\n\n\nvar\n \ndataString\n \n=\n \n'{\"attributes\":{\"marketplace_id\":\"0cbae4bf-961d-43ea-b57b-f7fb07736747\"}}'\n;\n\n\n\nvar\n \noptions\n \n=\n \n{\n\n    \nurl\n:\n \n'http://api.daptin.com:6336/action/marketplace/refresh_marketplace_packages'\n,\n\n    \nmethod\n:\n \n'POST'\n,\n\n    \nheaders\n: \nheaders\n,\n\n    \nbody\n: \ndataString\n\n\n};\n\n\n\nfunction\n \ncallback\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n    \nif\n \n(\n!\nerror\n \n&&\n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n        \nconsole\n.\nlog\n(\nbody\n);\n\n    \n}\n\n\n}\n\n\n\nrequest\n(\noptions\n,\n \ncallback\n);\n\n\n\n\n\nGenerate random data\nLink\n\n\nGenerate random data of any entity type to play around. Takes in a \ncount\n parameter and generates that many rows. Daptin uses a fake data generator to generate quality random data for a wide variety of fields.\n\n\nvar\n \nrequest\n \n=\n \nrequire\n(\n'request'\n);\n\n\n\nvar\n \nheaders\n \n=\n \n{\n\n    \n'Authorization'\n:\n \n'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFydHBhcjFAZ21haWwuY29tIiwiZXhwIjoxNTIzMTgzMTA0LCJpYXQiOiIyMDE4LTA0LTA1VDE1OjU1OjA0LjYyMzU4NTYxKzA1OjMwIiwiaXNzIjoiZGFwdGluIiwianRpIjoiNmJhMmFhZjgtODBlNS00OGIwLTgwZmItMzEzYzk3Nzg0Y2E4IiwibmFtZSI6InBhcnRoIiwibmJmIjoxNTIyOTIzOTA0LCJwaWN0dXJlIjoiaHR0cHM6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci9mNGJmNmI2Nzg5NGU5MzAzYjZlMTczMTMyZWE0ZTkwYVx1MDAyNmQ9bW9uc3RlcmlkIn0.eb5Vp00cHLeshZBtwJIyarJ6RQOLeVPj15n8ubVnGYo'\n,\n\n\n};\n\n\n\nvar\n \ndataString\n \n=\n \n'{\"attributes\":{\"count\":100,\"world_id\":\"a82bcd84-db3a-4542-b0ef-80e81fc62f8e\"}}'\n;\n\n\n\nvar\n \noptions\n \n=\n \n{\n\n    \nurl\n:\n \n'http://api.daptin.com:6336/action/world/generate_random_data'\n,\n\n    \nmethod\n:\n \n'POST'\n,\n\n    \nheaders\n: \nheaders\n,\n\n    \nbody\n: \ndataString\n\n\n};\n\n\n\nfunction\n \ncallback\n(\nerror\n,\n \nresponse\n,\n \nbody\n)\n \n{\n\n    \nif\n \n(\n!\nerror\n \n&&\n \nresponse\n.\nstatusCode\n \n==\n \n200\n)\n \n{\n\n        \nconsole\n.\nlog\n(\nbody\n);\n\n    \n}\n\n\n}\n\n\n\nrequest\n(\noptions\n,\n \ncallback\n);\n\n\n\n\n\nInstall package from market\nLink\n\n\nInstall a package (data models, relations, actions, sites) from a \nmarket\n using a \npackage name\n. This will reconfigure daptin and apply the necessary changes. Note: any updates to this package in the marketplace will not be imported automatically.\n\n\nExport data\nLink\n\n\n\n\nExport data as JSON dump. This will export for a single table if \ntable_name\n param is specific, else it will export all data.\n\n\n\n\nImport data\nLink\n\n\n\n\nImport data from dump exported by Daptin. Takes in the following parameters:\n\n\n\n\ndump_file - json|yaml|toml|hcl\n\n\ntruncate_before_insert: default \nfalse\n, specify \ntrue\n to tuncate tables before importing\n\n\n\n\n\n\nUpload file to a cloud store\nLink\n\n\n\n\nUpload file to external store \ncloud_store\n, may require \noauth token and connection\n.\n\n\n\n\nfile: any\n\n\n\n\n\n\nUpload XLS\nLink\n\n\n\n\nUpload xls to entity, takes in the following parameters:\n\n\n\n\ndata_xls_file: xls, xlsx\n\n\nentity_name: existing table name or new to create a new entity\n\n\ncreate_if_not_exists: set \ntrue\n if creating a new entity (to avoid typo errors in above)\n\n\nadd_missing_columns: set \ntrue\n if the file has extra columns which you want to be created\n\n\n\n\n\n\nUpload CSV\nLink\n\n\n\n\nUpload CSV to entity\n\n\n\n\ndata_xls_file: xls, xlsx\n\n\nentity_name: existing table name or new to create a new entity\n\n\ncreate_if_not_exists: set \ntrue\n if creating a new entity (to avoid typo errors in above)\n\n\nadd_missing_columns: set \ntrue\n if the file has extra columns which you want to be created\n\n\n\n\n\n\n\n\nCurl\n\n\n\n\ncurl\n \n'http://api.daptin.com:6336/action/world/upload_csv_to_system_schema'\n \n\\\n\n\n-H\n \n'Authorization: Bearer <Token>'\n \n\\\n\n\n--data-binary\n \n'{\n\n\n                \"attributes\": {\n\n\n                    \"create_if_not_exists\": true,\n\n\n                    \"add_missing_columns\": true,\n\n\n                    \"data_csv_file\": \n[\n{\n\n                        \n\"name\"\n:\n \n\"<file name>.csv\"\n,\n\n                        \n\"file\"\n:\n \n\"data:text/csv;base64,<File contents base64 here>\"\n,\n\n                        \n\"type\"\n:\n \n\"text/csv\"\n\n                    \n}\n]\n,\n\n\n                    \"entity_name\": \"<entity name>\"\n\n\n                  }\n\n\n               }'\n\n\n\n\n\n\n\nNodeJS Example\n\n\nimport\n \nrequests\n\n\n\nheaders\n \n=\n \n{\n\n    \n'Authorization'\n:\n \n'Bearer <Token>'\n,\n\n\n}\n\n\n\ndata\n \n=\n  \n'{\n\n            \n\"attributes\"\n:\n \n{\n\n                \n\"create_if_not_exists\"\n:\n \ntrue\n,\n\n                \n\"add_missing_columns\"\n:\n \ntrue\n,\n\n                \n\"data_csv_file\"\n:\n \n[{\n\n                    \n\"name\"\n:\n \n\"<file name>.csv\"\n,\n\n                    \n\"file\"\n:\n \n\"data:text/csv;base64,<File contents base64 here>\"\n,\n\n                    \n\"type\"\n:\n \n\"text/csv\"\n\n                \n}],\n\n                \n\"entity_name\"\n:\n \n\"<entity name>\"\n\n              \n}\n\n          \n}\n'\n\n\n\nresponse\n \n=\n \nrequests\n.\npost\n(\n'http://api.daptin.com:6336/action/world/upload_csv_to_system_schema'\n,\n \nheaders\n=\nheaders\n,\n \ndata\n=\ndata\n)\n\n\n\n\n\n\n\nUpload schema\nLink\n\n\n\n\nUpload entity types or actions or any other config to daptin\n\n\n\n\nschema_file: json|yaml|toml|hcl\n\n\n\n\nrestart, system_json_schema_update\n\n\n\n\nDownload Schema\nLink\n\n\n\n\nDownload a JSON config of the current daptin instance. This can be imported at a later stage to recreate a similar instance. Note, this contains only the structure and not the actual data. You can take a \ndata dump\n separately. Or of a particular entity type\n\n\n\n\nBecome administrator\nLink\n\n\n\n\nBecome an admin user of the instance. Only the first user can do this, as long as there is no second user.\n\n\n\n\nSign up\nLink\n\n\n\n\nSign up a new user, takes in the following parameters\n\n\n\n\nname\n\n\nemail\n\n\npassword\n\n\npasswordConfirm\n\n\n\n\nCreates these rows :\n\n\n\n\na new user\n\n\na new usergroup for the user\n\n\nuser belongs to the usergroup\n\n\n\n\n\n\nSign in\nLink\n\n\n\n\nSign in essentially generates a [JWT token] issued by Daptin which can be used in requests to authenticate as a user.\n\n\n\n\nemail\n\n\npassword\n\n\n\n\n\n\nOauth login\nLink\n\n\n\n\nAuthenticate via OAuth, this will redirect you to the oauth sign in page of the oauth connection. The response will be handeled by \noauth login response\n\n\n\n\nOauth login response\nLink\n\n\n\n\nThis action is supposed to handle the oauth login response flow and not supposed to be invoked manually.\n\n\nTakes in the following parameters (standard oauth2 params)\n- code\n- state\n- authenticator\n\n\nCreates :\n\n\n\n\noauth profile exchange: generate a token from oauth provider\n\n\nstores the oauth token + refresh token for later user\n\n\n\n\n\n\nAdd data exchange\nLink\n\n\n\n\nAdd new data sync with google-sheets\n\n\n\n\nname\n\n\nsheet_id\n\n\napp_key\n\n\n\n\nCreates a data exchange\n\n\n\n\nPublish package to marketplace\nLink\n\n\n\n\nExport the JSON schema of your APIs to be re-used by other users from a \nmarketplace\n.\n\n\n\n\nUpdate package list\nLink\n\n\n\n\nExports the schema of your APIs as a package to a \nmarketplace\n. You can later install this package.\n\n\n\n\nVisit marketplace\nLink\n\n\n\n\nRedirects you to the \nmarketplace\n repository",
            "title": "Actions list"
        },
        {
            "location": "/actions/default_actions/#actions",
            "text": "Use actions to build work flows to carry out tasks like syncing data or emailing your users. You can also give access to these workflows to your users and restrict their access by altering their  permission .",
            "title": "Actions"
        },
        {
            "location": "/actions/default_actions/#restart-daptin",
            "text": "Restarts daptin immediately and reads file system for new config and data files and apply updates to the APIs as necessary.  Takes about 15 seconds (async) to reconfigure everything.  var   request   =   require ( 'request' );  var   headers   =   { \n     'Authorization' :   'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFydHBhcjFAZ21haWwuY29tIiwiZXhwIjoxNTIzMTgzMTA0LCJpYXQiOiIyMDE4LTA0LTA1VDE1OjU1OjA0LjYyMzU4NTYxKzA1OjMwIiwiaXNzIjoiZGFwdGluIiwianRpIjoiNmJhMmFhZjgtODBlNS00OGIwLTgwZmItMzEzYzk3Nzg0Y2E4IiwibmFtZSI6InBhcnRoIiwibmJmIjoxNTIyOTIzOTA0LCJwaWN0dXJlIjoiaHR0cHM6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci9mNGJmNmI2Nzg5NGU5MzAzYjZlMTczMTMyZWE0ZTkwYVx1MDAyNmQ9bW9uc3RlcmlkIn0.eb5Vp00cHLeshZBtwJIyarJ6RQOLeVPj15n8ubVnGYo'  };  var   dataString   =   '{\"attributes\":{}}' ;  var   options   =   { \n     url :   'http://api.daptin.com:6336/action/world/restart_daptin' , \n     method :   'POST' , \n     headers :  headers , \n     body :  dataString  };  function   callback ( error ,   response ,   body )   { \n     if   ( ! error   &&   response . statusCode   ==   200 )   { \n         console . log ( body ); \n     }  }  request ( options ,   callback );",
            "title": "Restart daptin"
        },
        {
            "location": "/actions/default_actions/#refresh-marketplace-packages",
            "text": "Pull updates from marketplace repository. New changes are not applied immediately and these packages should be installed again for updates.  var   request   =   require ( 'request' );  var   headers   =   { \n     'Authorization' :   'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFydHBhcjFAZ21haWwuY29tIiwiZXhwIjoxNTIzMTgzMTA0LCJpYXQiOiIyMDE4LTA0LTA1VDE1OjU1OjA0LjYyMzU4NTYxKzA1OjMwIiwiaXNzIjoiZGFwdGluIiwianRpIjoiNmJhMmFhZjgtODBlNS00OGIwLTgwZmItMzEzYzk3Nzg0Y2E4IiwibmFtZSI6InBhcnRoIiwibmJmIjoxNTIyOTIzOTA0LCJwaWN0dXJlIjoiaHR0cHM6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci9mNGJmNmI2Nzg5NGU5MzAzYjZlMTczMTMyZWE0ZTkwYVx1MDAyNmQ9bW9uc3RlcmlkIn0.eb5Vp00cHLeshZBtwJIyarJ6RQOLeVPj15n8ubVnGYo'  };  var   dataString   =   '{\"attributes\":{\"marketplace_id\":\"0cbae4bf-961d-43ea-b57b-f7fb07736747\"}}' ;  var   options   =   { \n     url :   'http://api.daptin.com:6336/action/marketplace/refresh_marketplace_packages' , \n     method :   'POST' , \n     headers :  headers , \n     body :  dataString  };  function   callback ( error ,   response ,   body )   { \n     if   ( ! error   &&   response . statusCode   ==   200 )   { \n         console . log ( body ); \n     }  }  request ( options ,   callback );",
            "title": "Refresh marketplace packages"
        },
        {
            "location": "/actions/default_actions/#generate-random-data",
            "text": "Generate random data of any entity type to play around. Takes in a  count  parameter and generates that many rows. Daptin uses a fake data generator to generate quality random data for a wide variety of fields.  var   request   =   require ( 'request' );  var   headers   =   { \n     'Authorization' :   'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFydHBhcjFAZ21haWwuY29tIiwiZXhwIjoxNTIzMTgzMTA0LCJpYXQiOiIyMDE4LTA0LTA1VDE1OjU1OjA0LjYyMzU4NTYxKzA1OjMwIiwiaXNzIjoiZGFwdGluIiwianRpIjoiNmJhMmFhZjgtODBlNS00OGIwLTgwZmItMzEzYzk3Nzg0Y2E4IiwibmFtZSI6InBhcnRoIiwibmJmIjoxNTIyOTIzOTA0LCJwaWN0dXJlIjoiaHR0cHM6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci9mNGJmNmI2Nzg5NGU5MzAzYjZlMTczMTMyZWE0ZTkwYVx1MDAyNmQ9bW9uc3RlcmlkIn0.eb5Vp00cHLeshZBtwJIyarJ6RQOLeVPj15n8ubVnGYo' ,  };  var   dataString   =   '{\"attributes\":{\"count\":100,\"world_id\":\"a82bcd84-db3a-4542-b0ef-80e81fc62f8e\"}}' ;  var   options   =   { \n     url :   'http://api.daptin.com:6336/action/world/generate_random_data' , \n     method :   'POST' , \n     headers :  headers , \n     body :  dataString  };  function   callback ( error ,   response ,   body )   { \n     if   ( ! error   &&   response . statusCode   ==   200 )   { \n         console . log ( body ); \n     }  }  request ( options ,   callback );",
            "title": "Generate random data"
        },
        {
            "location": "/actions/default_actions/#install-package-from-market",
            "text": "Install a package (data models, relations, actions, sites) from a  market  using a  package name . This will reconfigure daptin and apply the necessary changes. Note: any updates to this package in the marketplace will not be imported automatically.",
            "title": "Install package from market"
        },
        {
            "location": "/actions/default_actions/#export-data",
            "text": "Export data as JSON dump. This will export for a single table if  table_name  param is specific, else it will export all data.",
            "title": "Export data"
        },
        {
            "location": "/actions/default_actions/#import-data",
            "text": "Import data from dump exported by Daptin. Takes in the following parameters:   dump_file - json|yaml|toml|hcl  truncate_before_insert: default  false , specify  true  to tuncate tables before importing",
            "title": "Import data"
        },
        {
            "location": "/actions/default_actions/#upload-file-to-a-cloud-store",
            "text": "Upload file to external store  cloud_store , may require  oauth token and connection .   file: any",
            "title": "Upload file to a cloud store"
        },
        {
            "location": "/actions/default_actions/#upload-xls",
            "text": "Upload xls to entity, takes in the following parameters:   data_xls_file: xls, xlsx  entity_name: existing table name or new to create a new entity  create_if_not_exists: set  true  if creating a new entity (to avoid typo errors in above)  add_missing_columns: set  true  if the file has extra columns which you want to be created",
            "title": "Upload XLS"
        },
        {
            "location": "/actions/default_actions/#upload-csv",
            "text": "Upload CSV to entity   data_xls_file: xls, xlsx  entity_name: existing table name or new to create a new entity  create_if_not_exists: set  true  if creating a new entity (to avoid typo errors in above)  add_missing_columns: set  true  if the file has extra columns which you want to be created     Curl   curl   'http://api.daptin.com:6336/action/world/upload_csv_to_system_schema'   \\  -H   'Authorization: Bearer <Token>'   \\  --data-binary   '{                  \"attributes\": {                      \"create_if_not_exists\": true,                      \"add_missing_columns\": true,                      \"data_csv_file\":  [ { \n                         \"name\" :   \"<file name>.csv\" , \n                         \"file\" :   \"data:text/csv;base64,<File contents base64 here>\" , \n                         \"type\" :   \"text/csv\" \n                     } ] ,                      \"entity_name\": \"<entity name>\"                    }                 }'    NodeJS Example  import   requests  headers   =   { \n     'Authorization' :   'Bearer <Token>' ,  }  data   =    '{ \n             \"attributes\" :   { \n                 \"create_if_not_exists\" :   true , \n                 \"add_missing_columns\" :   true , \n                 \"data_csv_file\" :   [{ \n                     \"name\" :   \"<file name>.csv\" , \n                     \"file\" :   \"data:text/csv;base64,<File contents base64 here>\" , \n                     \"type\" :   \"text/csv\" \n                 }], \n                 \"entity_name\" :   \"<entity name>\" \n               } \n           } '  response   =   requests . post ( 'http://api.daptin.com:6336/action/world/upload_csv_to_system_schema' ,   headers = headers ,   data = data )",
            "title": "Upload CSV"
        },
        {
            "location": "/actions/default_actions/#upload-schema",
            "text": "Upload entity types or actions or any other config to daptin   schema_file: json|yaml|toml|hcl   restart, system_json_schema_update",
            "title": "Upload schema"
        },
        {
            "location": "/actions/default_actions/#download-schema",
            "text": "Download a JSON config of the current daptin instance. This can be imported at a later stage to recreate a similar instance. Note, this contains only the structure and not the actual data. You can take a  data dump  separately. Or of a particular entity type",
            "title": "Download Schema"
        },
        {
            "location": "/actions/default_actions/#become-administrator",
            "text": "Become an admin user of the instance. Only the first user can do this, as long as there is no second user.",
            "title": "Become administrator"
        },
        {
            "location": "/actions/default_actions/#sign-up",
            "text": "Sign up a new user, takes in the following parameters   name  email  password  passwordConfirm   Creates these rows :   a new user  a new usergroup for the user  user belongs to the usergroup",
            "title": "Sign up"
        },
        {
            "location": "/actions/default_actions/#sign-in",
            "text": "Sign in essentially generates a [JWT token] issued by Daptin which can be used in requests to authenticate as a user.   email  password",
            "title": "Sign in"
        },
        {
            "location": "/actions/default_actions/#oauth-login",
            "text": "Authenticate via OAuth, this will redirect you to the oauth sign in page of the oauth connection. The response will be handeled by  oauth login response",
            "title": "Oauth login"
        },
        {
            "location": "/actions/default_actions/#oauth-login-response",
            "text": "This action is supposed to handle the oauth login response flow and not supposed to be invoked manually.  Takes in the following parameters (standard oauth2 params)\n- code\n- state\n- authenticator  Creates :   oauth profile exchange: generate a token from oauth provider  stores the oauth token + refresh token for later user",
            "title": "Oauth login response"
        },
        {
            "location": "/actions/default_actions/#add-data-exchange",
            "text": "Add new data sync with google-sheets   name  sheet_id  app_key   Creates a data exchange",
            "title": "Add data exchange"
        },
        {
            "location": "/actions/default_actions/#publish-package-to-marketplace",
            "text": "Export the JSON schema of your APIs to be re-used by other users from a  marketplace .",
            "title": "Publish package to marketplace"
        },
        {
            "location": "/actions/default_actions/#update-package-list",
            "text": "Exports the schema of your APIs as a package to a  marketplace . You can later install this package.",
            "title": "Update package list"
        },
        {
            "location": "/actions/default_actions/#visit-marketplace",
            "text": "Redirects you to the  marketplace  repository",
            "title": "Visit marketplace"
        },
        {
            "location": "/actions/signup/",
            "text": "User signup/registration API\nLink\n\n\nSign up action can be allowed to guests to allow open registration by anyone. Users with enough permission over the \nuser\n table can create users manually.\n\n\nUsers registered using signup action are their own owners. Hence they can update and delete themselves. These permission can be changed based on the use case.\n\n\n\n\nPOST call for user registration\n\n\ncurl \n'http://api.daptin.com:6336/action/user/signup'\n \n\\\n\n-H \n'Authorization: Bearer null'\n \n\\\n\n-H \n'Content-Type: application/json;charset=UTF-8'\n \n\\\n\n-H \n'Accept: application/json, text/plain, */*'\n \n\\\n\n--data-binary \n'{\"attributes\":{\"name\":\"username\",\"email\":\"<UserEmail>\",\"password\":\"<Password>\",\"passwordConfirm\":\"<Password>\"}}'\n\n\n\n\n\n\n\nYou can either allow guests to be able to invoke \nsign up\n action or allow only a particular user to be able to create new users or a usergroup.\n\n\n[\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.notify\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"message\"\n:\n \n\"Created user\"\n,\n\n      \n\"title\"\n:\n \n\"Success\"\n,\n\n      \n\"type\"\n:\n \n\"success\"\n\n    \n}\n\n  \n}\n\n\n]\n\n\n\n\n\nThis user can sign in now (generate an auth token). But what he can access is again based on the permission of the system.",
            "title": "User registration/signup"
        },
        {
            "location": "/actions/signup/#user-signupregistration-api",
            "text": "Sign up action can be allowed to guests to allow open registration by anyone. Users with enough permission over the  user  table can create users manually.  Users registered using signup action are their own owners. Hence they can update and delete themselves. These permission can be changed based on the use case.   POST call for user registration  curl  'http://api.daptin.com:6336/action/user/signup'   \\ \n-H  'Authorization: Bearer null'   \\ \n-H  'Content-Type: application/json;charset=UTF-8'   \\ \n-H  'Accept: application/json, text/plain, */*'   \\ \n--data-binary  '{\"attributes\":{\"name\":\"username\",\"email\":\"<UserEmail>\",\"password\":\"<Password>\",\"passwordConfirm\":\"<Password>\"}}'    You can either allow guests to be able to invoke  sign up  action or allow only a particular user to be able to create new users or a usergroup.  [ \n   { \n     \"ResponseType\" :   \"client.notify\" , \n     \"Attributes\" :   { \n       \"message\" :   \"Created user\" , \n       \"title\" :   \"Success\" , \n       \"type\" :   \"success\" \n     } \n   }  ]   This user can sign in now (generate an auth token). But what he can access is again based on the permission of the system.",
            "title": "User signup/registration API"
        },
        {
            "location": "/actions/signin/",
            "text": "User sign in API\nLink\n\n\n\n\nPOST call for sign in\n\n\ncurl \n'http://api.daptin.com:6336/action/user/signin'\n \n\\\n\n-H \n'Content-Type: application/json;charset=UTF-8'\n \n\\\n\n-H \n'Accept: application/json, text/plain, */*'\n \n\\\n\n--data-binary \n'{\"attributes\":{\"email\":\"<Email>\",\"password\":\"<Password>\"}}'\n\n\n\n\n\n\n\n[\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.store.set\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"key\"\n:\n \n\"token\"\n,\n\n      \n\"value\"\n:\n \n\"<AccessToken>\"\n\n    \n}\n\n  \n},\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.notify\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"message\"\n:\n \n\"Logged in\"\n,\n\n      \n\"title\"\n:\n \n\"Success\"\n,\n\n      \n\"type\"\n:\n \n\"success\"\n\n    \n}\n\n  \n},\n\n  \n{\n\n    \n\"ResponseType\"\n:\n \n\"client.redirect\"\n,\n\n    \n\"Attributes\"\n:\n \n{\n\n      \n\"delay\"\n:\n \n2000\n,\n\n      \n\"location\"\n:\n \n\"/\"\n,\n\n      \n\"window\"\n:\n \n\"self\"\n\n    \n}\n\n  \n}\n\n\n]",
            "title": "User login/signin"
        },
        {
            "location": "/actions/signin/#user-sign-in-api",
            "text": "POST call for sign in  curl  'http://api.daptin.com:6336/action/user/signin'   \\ \n-H  'Content-Type: application/json;charset=UTF-8'   \\ \n-H  'Accept: application/json, text/plain, */*'   \\ \n--data-binary  '{\"attributes\":{\"email\":\"<Email>\",\"password\":\"<Password>\"}}'    [ \n   { \n     \"ResponseType\" :   \"client.store.set\" , \n     \"Attributes\" :   { \n       \"key\" :   \"token\" , \n       \"value\" :   \"<AccessToken>\" \n     } \n   }, \n   { \n     \"ResponseType\" :   \"client.notify\" , \n     \"Attributes\" :   { \n       \"message\" :   \"Logged in\" , \n       \"title\" :   \"Success\" , \n       \"type\" :   \"success\" \n     } \n   }, \n   { \n     \"ResponseType\" :   \"client.redirect\" , \n     \"Attributes\" :   { \n       \"delay\" :   2000 , \n       \"location\" :   \"/\" , \n       \"window\" :   \"self\" \n     } \n   }  ]",
            "title": "User sign in API"
        },
        {
            "location": "/state/machines/",
            "text": "State machine\nLink\n\n\nState of an object can help you tracing any sort of progress while making sure you maintain the consistence of the state. For eg, you might want to track the status of a \"blog post\" in terms of \"draft\"/\"edited\"/\"published\" which pre-defined endpoints defining the flow of states.\n\n\nDefining a state machine\nLink\n\n\nDefine a state machine in YAML or JSON as follows:\n\n\n\n\nState machine description YAML\n\n\nStateMachineDescriptions\n:\n\n\n-\n \nName\n:\n \ntask_status\n\n  \nLabel\n:\n \nTask Status\n\n  \nInitialState\n:\n \nto_be_done\n\n  \nEvents\n:\n\n  \n-\n \nName\n:\n \nstart\n\n    \nLabel\n:\n \nStart\n\n    \nSrc\n:\n\n    \n-\n \nto_be_done\n\n    \n-\n \ndelayed\n\n    \nDst\n:\n \nstarted\n\n  \n-\n \nName\n:\n \ndelayed\n\n    \nLabel\n:\n \nUnable to pick up\n\n    \nSrc\n:\n\n    \n-\n \nto_be_done\n\n    \nDst\n:\n \ndelayed\n\n  \n-\n \nName\n:\n \nongoing\n\n    \nLabel\n:\n \nRecord progress\n\n    \nSrc\n:\n\n    \n-\n \nstarted\n\n    \n-\n \nongoing\n\n    \nDst\n:\n \nongoing\n\n  \n-\n \nName\n:\n \ninterrupted\n\n    \nLabel\n:\n \nInterrupted\n\n    \nSrc\n:\n\n    \n-\n \nstarted\n\n    \n-\n \nongoing\n\n    \nDst\n:\n \ninterrupted\n\n  \n-\n \nName\n:\n \nresume\n\n    \nLabel\n:\n \nResume from interruption\n\n    \nSrc\n:\n\n    \n-\n \ninterrupted\n\n    \nDst\n:\n \nongoing\n\n  \n-\n \nName\n:\n \ncompleted\n\n    \nLabel\n:\n \nMark as completed\n\n    \nSrc\n:\n\n    \n-\n \nongoing\n\n    \n-\n \nstarted\n\n    \nDst\n:\n \ncompleted\n\n\n\n\n\n\n\nUsing state machine descriptions with daptin expose couple of super useful apis to manage state based data.\n\n\nEnabling \ntask_status\n state machine on \ntodo\n entity will expose the following APIs\n\n\nPOST /track/start/:stateMachineId \n{\n\"typeName\"\n: \n\"todo\"\n, \n\"referenceId\"\n: \n\"objectId\"\n}\n \n# Start tracking a particular object by id\n\n\n\n\n\nThis returns a state machine id.\n\n\nPOST /track/event/:typename/:objectStateMachineId/:eventName \n{}\n \n# Trigger event on current state\n\n\n\n\n\nThis either moves the \nobject state\n to next state, or fails on invalid event name.",
            "title": "State machines"
        },
        {
            "location": "/state/machines/#state-machine",
            "text": "State of an object can help you tracing any sort of progress while making sure you maintain the consistence of the state. For eg, you might want to track the status of a \"blog post\" in terms of \"draft\"/\"edited\"/\"published\" which pre-defined endpoints defining the flow of states.",
            "title": "State machine"
        },
        {
            "location": "/state/machines/#defining-a-state-machine",
            "text": "Define a state machine in YAML or JSON as follows:   State machine description YAML  StateMachineDescriptions :  -   Name :   task_status \n   Label :   Task Status \n   InitialState :   to_be_done \n   Events : \n   -   Name :   start \n     Label :   Start \n     Src : \n     -   to_be_done \n     -   delayed \n     Dst :   started \n   -   Name :   delayed \n     Label :   Unable to pick up \n     Src : \n     -   to_be_done \n     Dst :   delayed \n   -   Name :   ongoing \n     Label :   Record progress \n     Src : \n     -   started \n     -   ongoing \n     Dst :   ongoing \n   -   Name :   interrupted \n     Label :   Interrupted \n     Src : \n     -   started \n     -   ongoing \n     Dst :   interrupted \n   -   Name :   resume \n     Label :   Resume from interruption \n     Src : \n     -   interrupted \n     Dst :   ongoing \n   -   Name :   completed \n     Label :   Mark as completed \n     Src : \n     -   ongoing \n     -   started \n     Dst :   completed    Using state machine descriptions with daptin expose couple of super useful apis to manage state based data.  Enabling  task_status  state machine on  todo  entity will expose the following APIs  POST /track/start/:stateMachineId  { \"typeName\" :  \"todo\" ,  \"referenceId\" :  \"objectId\" }   # Start tracking a particular object by id   This returns a state machine id.  POST /track/event/:typename/:objectStateMachineId/:eventName  {}   # Trigger event on current state   This either moves the  object state  to next state, or fails on invalid event name.",
            "title": "Defining a state machine"
        },
        {
            "location": "/auth/guests/",
            "text": "Guests\nLink\n\n\n\n\nRequests \nwithout\n a valid \nAuthorization Bearer\n \ntoken\n will be referred to as \"guests requests\". Requests with a valid token will have an identified user in the context.\n\n\nSign-up\nLink\n\n\nGuests can be given permission to execute signup action and so allowing them to register themselves.\n\n\nSocial login\nLink\n\n\nOauth connection can be used to allow guests to identify themselves based on the email provided by the oauth id provider.\n\n\nCheckout sample configurations here\n\n\nAuto add new users to groups\nLink\n\n\nYou can configure which usergroups should newly registered users be added to after their signup.\n\n\nThis can be configured in the table properties from the dashboard or by updating the entity configuration from the API",
            "title": "Guests"
        },
        {
            "location": "/auth/guests/#guests",
            "text": "Requests  without  a valid  Authorization Bearer   token  will be referred to as \"guests requests\". Requests with a valid token will have an identified user in the context.",
            "title": "Guests"
        },
        {
            "location": "/auth/guests/#sign-up",
            "text": "Guests can be given permission to execute signup action and so allowing them to register themselves.",
            "title": "Sign-up"
        },
        {
            "location": "/auth/guests/#social-login",
            "text": "Oauth connection can be used to allow guests to identify themselves based on the email provided by the oauth id provider.  Checkout sample configurations here",
            "title": "Social login"
        },
        {
            "location": "/auth/guests/#auto-add-new-users-to-groups",
            "text": "You can configure which usergroups should newly registered users be added to after their signup.  This can be configured in the table properties from the dashboard or by updating the entity configuration from the API",
            "title": "Auto add new users to groups"
        },
        {
            "location": "/auth/users/",
            "text": "Users\nLink\n\n\nDaptin has a built-in user system. Users are identified by their authorization token or other means of identification. Users are idenfied as registered users or guests.\n\n\nYou can choose to disable new user registration by changing the \nsignup\n action permissions.\n\n\nAPI\nLink\n\n\nUsers are just like any other data you maintain. Users information is stored in the \nuser\n table and exposed over \n/api/user\n endpoint.\n\n\nYou can choose to allow \nread/write\n permission directly to that \ntable\n to allow other users/processes to use this api to \nread/create/update/delete\n users.\n\n\nCURL\nLink\n\n\ncurl '/api/user' \\\n  -H 'Authorization: Bearer <Auth Token>' \\\n  --data-binary '{\n                    \"data\": {\n                        \"type\": \"user\",\n                        \"attributes\": {\n                            \"email\": \"test@user.com\",\n                            \"name\": \"test\",\n                            \"password\": \"password\",\n                        }\n                    }\n                 }'\n\n\n\n\nNode JS\nLink\n\n\nimport\n \nrequests\n\n\n\nheaders\n \n=\n \n{\n\n    \n'Authorization'\n:\n \n'Bearer <Auth Token>'\n,\n\n\n}\n\n\n\ndata\n \n=\n \n'{\n\n            \n\"data\"\n:\n \n{\n\n                \n\"type\"\n:\n \n\"user\"\n,\n\n                \n\"attributes\"\n:\n \n{\n\n                    \n\"email\"\n:\n \n\"test@user.com\"\n,\n\n                    \n\"name\"\n:\n \n\"test\"\n,\n\n                    \n\"password\"\n:\n \n\"password\"\n,\n\n                \n}\n\n            \n}\n\n        \n}\n'\n\n\n\nresponse\n \n=\n \nrequests\n.\npost\n(\n'http://api.daptin.com:6336/api/user'\n,\n \nheaders\n=\nheaders\n,\n \ndata\n=\ndata\n)\n\n\n\nYou can manually add users from the users page, or allow sign-up action to be performed by guests which will take care of creating a user and an associated usergroup for that user. All new signed up users will also be added to the \"users\" usergroup.\n\n\nUsing Dashboard\nLink\n\n\nYou can create a new user from the sign-up page on a new instance and later make that page available to guests.",
            "title": "Adding users"
        },
        {
            "location": "/auth/users/#users",
            "text": "Daptin has a built-in user system. Users are identified by their authorization token or other means of identification. Users are idenfied as registered users or guests.  You can choose to disable new user registration by changing the  signup  action permissions.",
            "title": "Users"
        },
        {
            "location": "/auth/users/#api",
            "text": "Users are just like any other data you maintain. Users information is stored in the  user  table and exposed over  /api/user  endpoint.  You can choose to allow  read/write  permission directly to that  table  to allow other users/processes to use this api to  read/create/update/delete  users.",
            "title": "API"
        },
        {
            "location": "/auth/users/#curl",
            "text": "curl '/api/user' \\\n  -H 'Authorization: Bearer <Auth Token>' \\\n  --data-binary '{\n                    \"data\": {\n                        \"type\": \"user\",\n                        \"attributes\": {\n                            \"email\": \"test@user.com\",\n                            \"name\": \"test\",\n                            \"password\": \"password\",\n                        }\n                    }\n                 }'",
            "title": "CURL"
        },
        {
            "location": "/auth/users/#node-js",
            "text": "import   requests  headers   =   { \n     'Authorization' :   'Bearer <Auth Token>' ,  }  data   =   '{ \n             \"data\" :   { \n                 \"type\" :   \"user\" , \n                 \"attributes\" :   { \n                     \"email\" :   \"test@user.com\" , \n                     \"name\" :   \"test\" , \n                     \"password\" :   \"password\" , \n                 } \n             } \n         } '  response   =   requests . post ( 'http://api.daptin.com:6336/api/user' ,   headers = headers ,   data = data )  \nYou can manually add users from the users page, or allow sign-up action to be performed by guests which will take care of creating a user and an associated usergroup for that user. All new signed up users will also be added to the \"users\" usergroup.",
            "title": "Node JS"
        },
        {
            "location": "/auth/users/#using-dashboard",
            "text": "You can create a new user from the sign-up page on a new instance and later make that page available to guests.",
            "title": "Using Dashboard"
        },
        {
            "location": "/auth/usergroups/",
            "text": "User Management\nLink\n\n\nDaptin natively manages users and usergroups so that it has no dependency on external user management services. Though it can be integrated with such services.\n\n\nUser groups\nLink\n\n\nUser groups is a group concept that helps you manage \"who\" can interact with daptin, and in what ways.\n\n\nUsers and Objects belong to one or more user group.",
            "title": "Usergroups"
        },
        {
            "location": "/auth/usergroups/#user-management",
            "text": "Daptin natively manages users and usergroups so that it has no dependency on external user management services. Though it can be integrated with such services.",
            "title": "User Management"
        },
        {
            "location": "/auth/usergroups/#user-groups",
            "text": "User groups is a group concept that helps you manage \"who\" can interact with daptin, and in what ways.  Users and Objects belong to one or more user group.",
            "title": "User groups"
        },
        {
            "location": "/auth/permissions/",
            "text": "Permission model\nLink\n\n\nEvery read/write to the system passes through two level of permission check.\n\n\n\n\nType level: apply permission on all types of entities at the same time\n\n\nData level: object level permission\n\n\n\n\nThe \nworld\n table contains two columns:\n\n\n\n\nPermission\n: defines the entity level permission\n\n\nDefault permission\n: defines the default permission for a new object of this entity type\n\n\n\n\nThe default permission for an object is picked from the default permission setting, and can be changed after the object creation (if the permission allows).\n\n\nPeek\nLink\n\n\nPeek\n gives access to the user to read data in the system but not allow it in response as data. So while the query to read the data will execute and certain \nactions\n can be allowed over them, directly trying to read the data in response will fail.\n\n\n[C] Create\nLink\n\n\nCreate\n allows a new row to be created by using the POST api. Note: this doesn't apply over indirect creations using \nactions\n*.\n\n\n[R] Read\nLink\n\n\nRead\n allows the data to be served in the http response body. The response will usually follow the JSONAPI.org structure.\n\n\n[U] Update\nLink\n\n\nUpdate\n allows the data fields to be updated using the PUT/PATCH http methods.\n\n\n[D] Delete\nLink\n\n\nDelete\n gives permission to be delete a row or certain type of data using DELETE http method. Unless you have enabled \nauditing\n, you will permanently loose this data.\n\n\n[R] Refer\nLink\n\n\nRefer\n gives permission to add data/users to usergroups. Note that you will also need certain permission on the \nusergroup\n as well.\n\n\n[X] Execute\nLink\n\n\nExecute\n gives permission to invoke action over data (like export). Note that giving access to a \ntype of data\n doesn't give access to all rows of that \nentity type\n.",
            "title": "Data access permission"
        },
        {
            "location": "/auth/permissions/#permission-model",
            "text": "Every read/write to the system passes through two level of permission check.   Type level: apply permission on all types of entities at the same time  Data level: object level permission   The  world  table contains two columns:   Permission : defines the entity level permission  Default permission : defines the default permission for a new object of this entity type   The default permission for an object is picked from the default permission setting, and can be changed after the object creation (if the permission allows).",
            "title": "Permission model"
        },
        {
            "location": "/auth/permissions/#peek",
            "text": "Peek  gives access to the user to read data in the system but not allow it in response as data. So while the query to read the data will execute and certain  actions  can be allowed over them, directly trying to read the data in response will fail.",
            "title": "Peek"
        },
        {
            "location": "/auth/permissions/#c-create",
            "text": "Create  allows a new row to be created by using the POST api. Note: this doesn't apply over indirect creations using  actions *.",
            "title": "[C] Create"
        },
        {
            "location": "/auth/permissions/#r-read",
            "text": "Read  allows the data to be served in the http response body. The response will usually follow the JSONAPI.org structure.",
            "title": "[R] Read"
        },
        {
            "location": "/auth/permissions/#u-update",
            "text": "Update  allows the data fields to be updated using the PUT/PATCH http methods.",
            "title": "[U] Update"
        },
        {
            "location": "/auth/permissions/#d-delete",
            "text": "Delete  gives permission to be delete a row or certain type of data using DELETE http method. Unless you have enabled  auditing , you will permanently loose this data.",
            "title": "[D] Delete"
        },
        {
            "location": "/auth/permissions/#r-refer",
            "text": "Refer  gives permission to add data/users to usergroups. Note that you will also need certain permission on the  usergroup  as well.",
            "title": "[R] Refer"
        },
        {
            "location": "/auth/permissions/#x-execute",
            "text": "Execute  gives permission to invoke action over data (like export). Note that giving access to a  type of data  doesn't give access to all rows of that  entity type .",
            "title": "[X] Execute"
        },
        {
            "location": "/auth/social_login/",
            "text": "Social login\nLink\n\n\nAllow users to login using their existing social accounts like twitter/google/github.\n\n\nDaptin can work with any oauth flow aware identity provider to allow new users to be registered (if you have disabled normal signup).\n\n\nCreate a \nOAuth Connection\n and mark \"Allow login\" to enable APIs for OAuth flow.\n\n\nExamples\n\n\n\n\nGoogle login configuration\n\n\n\n\n\n\n\n\nDropbox login configuration\n\n\n\n\n\n\n\n\nGithub login configuration\n\n\n\n\n\n\n\n\nLinkedin login configuration\n\n\n\n\n\n\n\n\nEncrypted values\n\n\nThe secrets are stored after encryption so the value you see in above screenshots are encrypted values.",
            "title": "Social login"
        },
        {
            "location": "/auth/social_login/#social-login",
            "text": "Allow users to login using their existing social accounts like twitter/google/github.  Daptin can work with any oauth flow aware identity provider to allow new users to be registered (if you have disabled normal signup).  Create a  OAuth Connection  and mark \"Allow login\" to enable APIs for OAuth flow.  Examples   Google login configuration     Dropbox login configuration     Github login configuration     Linkedin login configuration     Encrypted values  The secrets are stored after encryption so the value you see in above screenshots are encrypted values.",
            "title": "Social login"
        },
        {
            "location": "/auth/authentication/",
            "text": "Authentication\nLink\n\n\nDaptin maintains its own user accounts and usergroups as well. Users are identified by \nemail\n which is a unique key in the \nuser\n entity. Passwords are stored using bcrypt with a cost of 11. Password field has a column_type \npassword\n which makes daptin to bcrypt it before storing, and password fields are never returned in any JSONAPI call.\n\n\nAuthentication token\nLink\n\n\nThe authentication token is a JWT token issued by daptin on sign in action. Users can create new actions to allow other means of generating JWT token. It is as simple as adding another outcome to an action.\n\n\nServer side\nLink\n\n\nDaptin uses oAuth2 based authentication strategy. HTTP calls are checked for \nAuthorization\n header, and if present, validated as a JWT token. The JWT token should have been issued by daptin earlier and should not have expired. To see how to generate JWT token, checkout the \nsing-in action\n.\n\n\nThe JWT token contains the issuer information (daptin) plus basic user profile (email). The JWT token has a one hour (configurable) expiry from the time of issue.\n\n\nIf the token is absent or invalid, the user is considered as a guest. Guests also have certain permissions. Checkout the \nAuthorization docs\n for details.\n\n\nClient side\nLink\n\n\nOn the client side, for dashboard, the token is stored in local storage. The local storage is cleared on logout or if the server responds with a 401 Unauthorized status.\n\n\nAuthentication using other systems\nLink\n\n\nThere is planned road map to allow user logins via external oauth2 servers as well (login via google/facebook/twitter... and so on). This feature is not complete yet. Documentation will be updated to reflect changes.\n\n\nSign Up\nLink\n\n\nSign up is an action on user entity. Sign up takes four inputs:\n\n\n\n\nName\n\n\nEmail\n\n\nPassword\n\n\nPasswordConfirm\n\n\n\n\nWhen the user initates a Sign up action, the following things happen\n\n\n\n\nCheck if guests can initiate sign in action\n\n\nCheck if guests can create a new user (create permission)\n\n\nCreate a new user row\n\n\nCheck if guests can create a new usergroup (create permission)\n\n\nCreate a new usergroup row\n\n\nAssociate the user to the usergroup (refer permission)\n\n\n\n\nThis means that every user has his own dedicated usergrou by default. \n\n\nSign In\nLink\n\n\nSign In is also an action on user entity. Sign in takes two inputs:\n\n\n\n\nEmail\n\n\nPassword\n\n\n\n\nWhen the user initiates Sign in action, the following things happen:\n\n\n\n\nCheck if guests can peek users table (Peek permission)\n\n\nCheck if guests can peek the particular user (Peek Permission)\n\n\nMatch if the provided password bcrypted matches the stored bcrypted password\n\n\nIf true, issue a JWT token, which is used for future calls\n\n\n\n\nThe main outcome of the Sign In action is the jwt token, which is to be used in the \nAuthorization\n header of following calls.",
            "title": "User Authentication"
        },
        {
            "location": "/auth/authentication/#authentication",
            "text": "Daptin maintains its own user accounts and usergroups as well. Users are identified by  email  which is a unique key in the  user  entity. Passwords are stored using bcrypt with a cost of 11. Password field has a column_type  password  which makes daptin to bcrypt it before storing, and password fields are never returned in any JSONAPI call.",
            "title": "Authentication"
        },
        {
            "location": "/auth/authentication/#authentication-token",
            "text": "The authentication token is a JWT token issued by daptin on sign in action. Users can create new actions to allow other means of generating JWT token. It is as simple as adding another outcome to an action.",
            "title": "Authentication token"
        },
        {
            "location": "/auth/authentication/#server-side",
            "text": "Daptin uses oAuth2 based authentication strategy. HTTP calls are checked for  Authorization  header, and if present, validated as a JWT token. The JWT token should have been issued by daptin earlier and should not have expired. To see how to generate JWT token, checkout the  sing-in action .  The JWT token contains the issuer information (daptin) plus basic user profile (email). The JWT token has a one hour (configurable) expiry from the time of issue.  If the token is absent or invalid, the user is considered as a guest. Guests also have certain permissions. Checkout the  Authorization docs  for details.",
            "title": "Server side"
        },
        {
            "location": "/auth/authentication/#client-side",
            "text": "On the client side, for dashboard, the token is stored in local storage. The local storage is cleared on logout or if the server responds with a 401 Unauthorized status.",
            "title": "Client side"
        },
        {
            "location": "/auth/authentication/#authentication-using-other-systems",
            "text": "There is planned road map to allow user logins via external oauth2 servers as well (login via google/facebook/twitter... and so on). This feature is not complete yet. Documentation will be updated to reflect changes.",
            "title": "Authentication using other systems"
        },
        {
            "location": "/auth/authentication/#sign-up",
            "text": "Sign up is an action on user entity. Sign up takes four inputs:   Name  Email  Password  PasswordConfirm   When the user initates a Sign up action, the following things happen   Check if guests can initiate sign in action  Check if guests can create a new user (create permission)  Create a new user row  Check if guests can create a new usergroup (create permission)  Create a new usergroup row  Associate the user to the usergroup (refer permission)   This means that every user has his own dedicated usergrou by default.",
            "title": "Sign Up"
        },
        {
            "location": "/auth/authentication/#sign-in",
            "text": "Sign In is also an action on user entity. Sign in takes two inputs:   Email  Password   When the user initiates Sign in action, the following things happen:   Check if guests can peek users table (Peek permission)  Check if guests can peek the particular user (Peek Permission)  Match if the provided password bcrypted matches the stored bcrypted password  If true, issue a JWT token, which is used for future calls   The main outcome of the Sign In action is the jwt token, which is to be used in the  Authorization  header of following calls.",
            "title": "Sign In"
        },
        {
            "location": "/auth/authorization/",
            "text": "Access Authorization\nLink\n\n\nAuthorization is the part where daptin decides if the caller has enough permission to execute the call. Currently daptin has the following permissions.\n\n\nEntity level permission check\nLink\n\n\nThe world table has the list of all entities. Consider the scenario where we created a todo list. The world table would have a row to represent this entity\n\n\n\n\n\n\n\n\nEntity\n\n\nPermission\n\n\n\n\n\n\n\n\n\n\ntodo\n\n\n112000006\n\n\n\n\n\n\n\n\nHere:\n\n\n\n\n112 is for owners, which basically means 64 + 32 + 16 = Refer/Execute/Delete\n\n\n000 is for group users, no permission allowed in this case\n\n\n006 is for guest users, which is 2 + 4 = Read/Create\n\n\n\n\nObject level permission check\nLink\n\n\nOnce the call clears the entity level check, an object level permission check is applied. This happens in cases where the action is going to affect/read an existing row. The permission is stored in the same way. Each table has a permission column which stores the permission in \nOOOGGGXXX\n format.\n\n\nOrder of permission check\nLink\n\n\nThe permission is checked in order of:\n\n\n\n\nCheck if the user is owner, if yes, check if permission allows the current action, if yes do action\n\n\nCheck if the user belongs to a group to which this object also belongs, if yes, check if permisison allows the current action, if yes do action\n\n\nUser is guest, check if guest permission allows this actions, if yes do action, if no, unauthorized\n\n\n\n\nThings to note here:\n\n\n\n\nThere is no negative permission (this may be introduced in the future)\n\n\neg, you cannot say owner is 'not allowed' to read but read by guest is allowed. \n\n\nPermission check is done in a hierarchy type order\n\n\n\n\nAccess flow\nLink\n\n\nEvery \"interaction\" in daptin goes through two levels of access. Each level has a \nbefore\n and \nafter\n check.\n\n\n\n\nEntity level access: does the user invoking the interaction has the appropriate permission to invoke this (So for sign up, the user table need to be writable by guests, for sign in the user table needs to be peakable by guests)\n\n\nInstance level access: this is the second level, even if a user has access to \"user\" entity, not all \"user\" rows would be accessible by them\n\n\n\n\nSo the actual checks happen in following order:\n\n\n\n\n\"Before check\" for entity\n\n\n\"Before check\" for instance\n\n\n\"After check\" for instance\n\n\n\"After check\" for entity\n\n\n\n\nEach of these checks can filter out objects where the user does not have enough permission.\n\n\nEntity level permission\nLink\n\n\nEntity level permission are set in the world table and can be updated from dashboard. This can be done by updating the \"permission\" column for the entity.\n\n\nFor these changes to take effect a restart is necessary.\n\n\nInstance level permission\nLink\n\n\nLike we saw in the \nentity documentation\n, every table has a \npermission\n column. No restart is necessary for changes in these permission.\n\n\nPermission column\nLink\n\n\nThe permission column contains a nine digit number, which decides the access for guests (the world), user groups and owner\n\n\nThe nine digits can be represented as follows:\n\n\nUUUGGGWWW\n\n\nEach entity has a permission field which is added by daptin. The permission field is a 9 digit number, in the following format\n\n\nThe first three digits(UUU) represent the permission for the owner.\nThe next three digits(GGG) represent the permission for the group.\nThe last three digits(WWW)  represent the permission for guest users.\n\n\nU = User\nG = Group\nW = World\n\n\n\n\nPeek - 1\n\n\nRead - 2\n\n\nCreate - 4\n\n\nUpdate - 8\n\n\nDelete - 16\n\n\nExecute - 32\n\n\nRefer - 64\n\n\n\n\nHere is another way of looking at it:\n\n\nPermissions:\n\n\n002,000,000 read by owner\n000,020,000 read by group\n000,000,002 read by anybody (other)\n004,000,000 write by owner\n000,004,000 write by group\n000,000,004 write by anybody\n032,000,000 execute by owner\n000,032,000 execute by group\n000,000,032 execute by anybody\n\n\nTo get a combination, just add them up.\n\n\nFor example, to get\n\n\n\n\nread, write, execute by owner\n\n\nread, execute, by group\n\n\nexecute by anybody\n\n\n\n\nyou would add (002 + 004 + 032),(002 + 032),(032) to give 038034032.",
            "title": "Authorization"
        },
        {
            "location": "/auth/authorization/#access-authorization",
            "text": "Authorization is the part where daptin decides if the caller has enough permission to execute the call. Currently daptin has the following permissions.",
            "title": "Access Authorization"
        },
        {
            "location": "/auth/authorization/#entity-level-permission-check",
            "text": "The world table has the list of all entities. Consider the scenario where we created a todo list. The world table would have a row to represent this entity     Entity  Permission      todo  112000006     Here:   112 is for owners, which basically means 64 + 32 + 16 = Refer/Execute/Delete  000 is for group users, no permission allowed in this case  006 is for guest users, which is 2 + 4 = Read/Create",
            "title": "Entity level permission check"
        },
        {
            "location": "/auth/authorization/#object-level-permission-check",
            "text": "Once the call clears the entity level check, an object level permission check is applied. This happens in cases where the action is going to affect/read an existing row. The permission is stored in the same way. Each table has a permission column which stores the permission in  OOOGGGXXX  format.",
            "title": "Object level permission check"
        },
        {
            "location": "/auth/authorization/#order-of-permission-check",
            "text": "The permission is checked in order of:   Check if the user is owner, if yes, check if permission allows the current action, if yes do action  Check if the user belongs to a group to which this object also belongs, if yes, check if permisison allows the current action, if yes do action  User is guest, check if guest permission allows this actions, if yes do action, if no, unauthorized   Things to note here:   There is no negative permission (this may be introduced in the future)  eg, you cannot say owner is 'not allowed' to read but read by guest is allowed.   Permission check is done in a hierarchy type order",
            "title": "Order of permission check"
        },
        {
            "location": "/auth/authorization/#access-flow",
            "text": "Every \"interaction\" in daptin goes through two levels of access. Each level has a  before  and  after  check.   Entity level access: does the user invoking the interaction has the appropriate permission to invoke this (So for sign up, the user table need to be writable by guests, for sign in the user table needs to be peakable by guests)  Instance level access: this is the second level, even if a user has access to \"user\" entity, not all \"user\" rows would be accessible by them   So the actual checks happen in following order:   \"Before check\" for entity  \"Before check\" for instance  \"After check\" for instance  \"After check\" for entity   Each of these checks can filter out objects where the user does not have enough permission.",
            "title": "Access flow"
        },
        {
            "location": "/auth/authorization/#entity-level-permission",
            "text": "Entity level permission are set in the world table and can be updated from dashboard. This can be done by updating the \"permission\" column for the entity.  For these changes to take effect a restart is necessary.",
            "title": "Entity level permission"
        },
        {
            "location": "/auth/authorization/#instance-level-permission",
            "text": "Like we saw in the  entity documentation , every table has a  permission  column. No restart is necessary for changes in these permission.",
            "title": "Instance level permission"
        },
        {
            "location": "/auth/authorization/#permission-column",
            "text": "The permission column contains a nine digit number, which decides the access for guests (the world), user groups and owner  The nine digits can be represented as follows:  UUUGGGWWW  Each entity has a permission field which is added by daptin. The permission field is a 9 digit number, in the following format  The first three digits(UUU) represent the permission for the owner.\nThe next three digits(GGG) represent the permission for the group.\nThe last three digits(WWW)  represent the permission for guest users.  U = User\nG = Group\nW = World   Peek - 1  Read - 2  Create - 4  Update - 8  Delete - 16  Execute - 32  Refer - 64   Here is another way of looking at it:  Permissions:  002,000,000 read by owner\n000,020,000 read by group\n000,000,002 read by anybody (other)\n004,000,000 write by owner\n000,004,000 write by group\n000,000,004 write by anybody\n032,000,000 execute by owner\n000,032,000 execute by group\n000,000,032 execute by anybody  To get a combination, just add them up.  For example, to get   read, write, execute by owner  read, execute, by group  execute by anybody   you would add (002 + 004 + 032),(002 + 032),(032) to give 038034032.",
            "title": "Permission column"
        },
        {
            "location": "/cloudstore/cloudstore/",
            "text": "Cloud store\nLink\n\n\nDatin can work with the following storage services:\n\n\n\n\nAmazon Drive  \n\n\nAmazon S3  \n\n\nBackblaze B2  \n\n\nBox  \n\n\nCeph  \n\n\nDigitalOcean Spaces  \n\n\nDreamhost  \n\n\nDropbox  \n\n\nFTP  \n\n\nGoogle Cloud Storage  \n\n\nGoogle Drive  \n\n\nHTTP  \n\n\nHubic  \n\n\nMemset Memstore  \n\n\nMicrosoft Azure Blob Storage  \n\n\nMicrosoft OneDrive  \n\n\nMinio  \n\n\nNextloud  \n\n\nOVH  \n\n\nOpenstack Swift  \n\n\nOracle Cloud Storage  \n\n\nOwnloud  \n\n\npCloud  \n\n\nput.io  \n\n\nQingStor  \n\n\nRackspace Cloud Files  \n\n\nSFTP  \n\n\nWasabi  \n\n\nWebDAV  \n\n\nYandex Disk  \n\n\nThe local filesystem  \n\n\n\n\nCreating a new cloud storage instance\nLink\n\n\nThing to keep ready\nLink\n\n\nIf the service you wan to integrate with requires authentication, create the following:\n\n\n\n\nAn \noauth connection\n\n\nAn \noauth token\n generated from the above connection\n\n\n\n\nSteps\nLink\n\n\n\n\nLogin to the dashboard\n\n\nClick \"Storage\" tile\n\n\nClick the green \"+\" icon on the top right\n\n\nUse the \nname\n to identify it uniquely\n\n\nRoot Path\n: in rclone format, eg\n\n\ngdrive: \ndrive:directory/subdirectory\n\n\ndropbox/ftp/local: \nremote/local:directory/subdirectory\n\n\nStore Provider\n: dropbox/drive/local/ftp...\n\n\nStore Type\n: cloud/local",
            "title": "Connecting with cloud store"
        },
        {
            "location": "/cloudstore/cloudstore/#cloud-store",
            "text": "Datin can work with the following storage services:   Amazon Drive    Amazon S3    Backblaze B2    Box    Ceph    DigitalOcean Spaces    Dreamhost    Dropbox    FTP    Google Cloud Storage    Google Drive    HTTP    Hubic    Memset Memstore    Microsoft Azure Blob Storage    Microsoft OneDrive    Minio    Nextloud    OVH    Openstack Swift    Oracle Cloud Storage    Ownloud    pCloud    put.io    QingStor    Rackspace Cloud Files    SFTP    Wasabi    WebDAV    Yandex Disk    The local filesystem",
            "title": "Cloud store"
        },
        {
            "location": "/cloudstore/cloudstore/#creating-a-new-cloud-storage-instance",
            "text": "",
            "title": "Creating a new cloud storage instance"
        },
        {
            "location": "/cloudstore/cloudstore/#thing-to-keep-ready",
            "text": "If the service you wan to integrate with requires authentication, create the following:   An  oauth connection  An  oauth token  generated from the above connection",
            "title": "Thing to keep ready"
        },
        {
            "location": "/cloudstore/cloudstore/#steps",
            "text": "Login to the dashboard  Click \"Storage\" tile  Click the green \"+\" icon on the top right  Use the  name  to identify it uniquely  Root Path : in rclone format, eg  gdrive:  drive:directory/subdirectory  dropbox/ftp/local:  remote/local:directory/subdirectory  Store Provider : dropbox/drive/local/ftp...  Store Type : cloud/local",
            "title": "Steps"
        },
        {
            "location": "/subsite/subsite/",
            "text": "Sub site\nLink\n\n\nYou can host multiple sites using daptin. A sub site is exposing a cloud storage folder statically under a sub-domain, domain or a path. \n\n\n\n\nExpose folders on cloud storage services as websites using your daptin instance.\n\n\n\n\nNew subsite\n\n\n\n\nSelect a cloud storage\n\n\nChoose a domain/sub-domain\n\n\nChoose a sub-path\n\n\n\n\n\n\nRestart is required to reflect changes.\n\n\nCreating a new sub-site\nLink\n\n\n\n\nExposing a folder as a subsite\n\n\n\n\nGoto dashboard \nhttps://dashboard.domain.com/\n\n\nClick \"Sub sites\"\n\n\nClick the green \"+\" icon\n\n\nType in the \nhostname\n this should be exposed to\n\n\nthis can be a domain or a sub-domain\n\n\nthe domain should be pointing to the daptin instance\n\n\nChoose a \nname\n\n\nPath\n: select a sub directory name to expose this sub-site. Your sub-site will be accessible at domain.com/\n\n\nCloud store Id\n: choose an existing \ncloud store\n.\n\n\n\n\nRestart to enable serving the site.\n\n\n\n\nDaptin will sync the cloud store locally and start serving it under the domain/path.",
            "title": "Creating a subsite"
        },
        {
            "location": "/subsite/subsite/#sub-site",
            "text": "You can host multiple sites using daptin. A sub site is exposing a cloud storage folder statically under a sub-domain, domain or a path.    Expose folders on cloud storage services as websites using your daptin instance.   New subsite   Select a cloud storage  Choose a domain/sub-domain  Choose a sub-path    Restart is required to reflect changes.",
            "title": "Sub site"
        },
        {
            "location": "/subsite/subsite/#creating-a-new-sub-site",
            "text": "Exposing a folder as a subsite   Goto dashboard  https://dashboard.domain.com/  Click \"Sub sites\"  Click the green \"+\" icon  Type in the  hostname  this should be exposed to  this can be a domain or a sub-domain  the domain should be pointing to the daptin instance  Choose a  name  Path : select a sub directory name to expose this sub-site. Your sub-site will be accessible at domain.com/  Cloud store Id : choose an existing  cloud store .   Restart to enable serving the site.   Daptin will sync the cloud store locally and start serving it under the domain/path.",
            "title": "Creating a new sub-site"
        },
        {
            "location": "/subsite/grapes/",
            "text": "GrapesJS\nLink\n\n\nTodo: add documentation around live website editing",
            "title": "Live editing a subsite"
        },
        {
            "location": "/subsite/grapes/#grapesjs",
            "text": "Todo: add documentation around live website editing",
            "title": "GrapesJS"
        },
        {
            "location": "/subsite/basic_auth/",
            "text": "Protecting subsites from guests\nLink\n\n\nIn addition to existing \nmeans of authentication\n, you can enable basic-auth over subsites since it is the quickest way to add authencation and doesn't require any action from end-users perspective apart from knowing the username and password. Also Basic auth is understood by a wide variety of browsers natively.",
            "title": "Basic Authentication"
        },
        {
            "location": "/subsite/basic_auth/#protecting-subsites-from-guests",
            "text": "In addition to existing  means of authentication , you can enable basic-auth over subsites since it is the quickest way to add authencation and doesn't require any action from end-users perspective apart from knowing the username and password. Also Basic auth is understood by a wide variety of browsers natively.",
            "title": "Protecting subsites from guests"
        },
        {
            "location": "/extend/marketplace/",
            "text": "Marketplace\nLink\n\n\nMarket places are git based repositories where you can keep your collections of schemas, to be re-used by you or others later.\n\n\nCreate a market place\nLink\n\n\n\n\nCreate a git repository\n\n\nGoto \nDashboard\n\n\nClick \nMarketplace\n\n\nClick PLUS icon to add a new marketplace\n\n\nEnter git endpoint\n\n\nEnter a name\n\n\nIf your packages are not at the root, then enter a path to the subpackages\n\n\nOr leave this path empty\n\n\n\n\nClick submit to add this. Remember to \"Sync repository\" once before installing a package.\n\n\nSyncing makes a local clone of the git repository for usage, or pulls for changes if it exists already.\n\n\nExample of a market place git repository\nLink\n\n\nCheckout a dummy market place\n with a couple of packages to be used\n\n\n\n\nBlog\n\n\nConstruction project management system\n\n\nFAQ management system\n\n\nStore management system\n\n\nFashion style management system\n\n\nTodo list\n\n\n\n\nInstall a package from a market place\nLink\n\n\n\n\nGoto \nDashboard\n\n\nClick \nMarketplace\n\n\nGo into a marketplace\n\n\nClick Action \"Install package\"\n\n\nType in the package name: this is the name of the folder you want to install\n\n\n\n\nSubmit to install this package. Daptin will restart itself and makes the changes to the APIs.",
            "title": "Marketplace"
        },
        {
            "location": "/extend/marketplace/#marketplace",
            "text": "Market places are git based repositories where you can keep your collections of schemas, to be re-used by you or others later.",
            "title": "Marketplace"
        },
        {
            "location": "/extend/marketplace/#create-a-market-place",
            "text": "Create a git repository  Goto  Dashboard  Click  Marketplace  Click PLUS icon to add a new marketplace  Enter git endpoint  Enter a name  If your packages are not at the root, then enter a path to the subpackages  Or leave this path empty   Click submit to add this. Remember to \"Sync repository\" once before installing a package.  Syncing makes a local clone of the git repository for usage, or pulls for changes if it exists already.",
            "title": "Create a market place"
        },
        {
            "location": "/extend/marketplace/#example-of-a-market-place-git-repository",
            "text": "Checkout a dummy market place  with a couple of packages to be used   Blog  Construction project management system  FAQ management system  Store management system  Fashion style management system  Todo list",
            "title": "Example of a market place git repository"
        },
        {
            "location": "/extend/marketplace/#install-a-package-from-a-market-place",
            "text": "Goto  Dashboard  Click  Marketplace  Go into a marketplace  Click Action \"Install package\"  Type in the package name: this is the name of the folder you want to install   Submit to install this package. Daptin will restart itself and makes the changes to the APIs.",
            "title": "Install a package from a market place"
        }
    ]
}